<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>LTH&#39;s note book</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="kyjo2014">
  
  
  <meta name="description" content="html|css|javascript|LTH&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LTH's note book">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LTH's note book">
<meta property="og:description" content="html|css|javascript|LTH&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LTH's note book">
<meta name="twitter:description" content="html|css|javascript|LTH&apos;s blog">
  
    <link rel="alternate" href="/atom.xml" title="LTH&#39;s note book" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">LTH&#39;s note book</a></h1>
    <p><a href="/">逗逼+未来の程序员</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/Reading">Reading</a></li>
      
        <li><a href="/about">About</a></li>
      
        <li><a href="/testing">TestArea</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/07/19/effective-JS/">
  <time datetime="2016-07-19T01:45:58.000Z">
    2016-07-19
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/07/19/effective-JS/">effective JS</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#了解你使用的JS版本<br>1.确定你的应用程序支持JS的哪些版本。<br>2.确保你使用的任何Js的特性对于应用程序将要运行的所有环境都是支持的。<br>3.总是在执行严格模式检查的环境中测试严格代码。<br>4.当心链接那些在不同严格模式下有不同预期的脚本。</p>
<p>#理解JS的浮点数<br>1.JS的数字都是双精度浮点数。<br>2.js中的证书仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型。<br>3.位运算符将数字视为32位的有符号整数。<br>4.当心浮点运算中的精度陷阱。</p>
<p>#当心隐式的强制类型转换<br>1.类型错误可能被隐式的强制转换所隐藏<br>2.重载的运算符+是进行加法运算还是字符串连接操作取决于其参数类型。<br>3.对象通过valueof方法强制转换为数字，通过toString方法强制转换为字符串。<br>4.对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串。<br>5.具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示。<br>6.测试一个值是否为未定义的值,应该使用typeof或者与undefined进行比较而不是使用真值运算。</p>
<p>#原始类型由于封装对象<br>1.当做相等比较时，原始类型的封装对象预期原是指行为不一样。<br>2.获取和设置原始类型值的属性会隐式地创建封装对象。</p>
<p>#避免对混合类型使用==运算符<br>1.当参数类型不同时， ==运算符应用了一套难以理解的隐式强制转换就能明白的比较运算。<br>2.使用===运算符，使读者不需要涉及任何的隐式强制转换就能明白你的比较运算符。<br>3.当比较不同类型的值时，使用你自己的现实强制转换是程序的行为更清晰。</p>
<p>#了解分号插入的局限</p>
<p>1.仅在“}”标记之前、一行的结束和程序的结束处推导分号。<br>2.仅在紧接着的标记不能被解析的时候推导分号。</p>
<ol>
<li>在以（、[、+、-或/字符开头的语句前绝不能省略分号。</li>
<li>当脚本链接的时候，在脚本之间显示地插入分号。<br>5.在return、throw、break\continue、或–的参数之前绝不能换行。<br>6.分号不能作为for循环的头部或空语句的分隔符而被推导出。</li>
</ol>
<p>#视字符串为16位的代码单元序列</p>
<p>1.JS字符串由16的代码单元组成，而不是由Unicode代码点组成。<br>2.js使用两个代码单元表示2^16，及其以上的Unicode代码点。这两个代码单元被称为代理对。<br>3.代理对甩开了字符串元素计数，length，charAt、charCodeAt方法以及正则表达式（例如“.”）受到了影响。<br>4.使用第三方的库编写可识别代码点的字符串操作。<br>5.每当你使用一个含有字符串操作的库时，你都需要查询该库的文档，看他如何处理代码点的整个范围</p>
<p>#尽量少用全局对象</p>
<p>1.避免声明全局变量<br>2.尽量声明局部变量<br>3.避免对全局对象添加属性、<br>4.使用全局对象类做平台特性检测。</p>
<p>#始终声明局部的变量<br>1.始终使用var声明新的局部变量。<br>2.考虑使用lint工具帮助检查为绑定的变量。</p>
<p>#避免使用with<br>1.避免使用with语句<br>2.使用简短的变量名代替重复访问的对象。<br>3.显示地绑定局部变量到对象属性上，而不要使用with语句隐式地绑定他们。</p>
<p>#熟练掌握闭包</p>
<p>1.函数可以引用定义在其外部作用域的变量<br>2.闭包比创建它们的函数具有更长的生命周期<br>3.闭包在内部存储其外部变量的引用，并能读写这些变量</p>
<p>#理解变量提升</p>
<p>1.在代码块中的变量声明会被隐式地提升到函数的顶部。<br>2.重声明变量被视为单个变量<br>3.考虑手动提升局部变量的声明，从而避免混肴。</p>
<p>#使用立即调用的函数表达式创建局部作用域</p>
<p>1，理解绑定与复制的区别。<br>2.闭包通过引用而不是值捕获它们的外部变量。<br>3.使用立即调用的函数表达式来创建局部作用域。<br>4.当心在立即调用的函数表达式中包裹代码块可能改变其行为的情形。</p>
<p>#当心命名函数表达式笨拙的作用域</p>
<p>1.在error对象和调试器中使用命名函数表达式改进栈跟踪<br>2.在ES3和有问题的JavaScript环境中谨记函数表达式作用域会被Object.prototype污染<br>3.谨记在错误百出的JavaScript环境中会提升命名函数声明，并导致命名函数表达式的重复存储。<br>4.考虑避免使用命名函数表达式或在发布前删除函数名<br>5.如果你将代码发布到正确实现的ES5环境中，那么你没有什么好担心的。</p>
<p>#当心局部快函数声明笨拙的作用域</p>
<p>1.始终将函数声明之雨程序或被包含的函数的自耦外层以避免不可抑制的行为。<br>2.使用var声明和有田间的赋值语句代替有条件的函数声明。</p>
<p>#避免使用eval创建局部变量</p>
<p>1.避免使用eval函数创建的变量污染调用者的作用域。<br>2.如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染。</p>
<p>#间接调用eval函数优于直接调用<br>1.将eval函数同毫无意义的一个字面量包裹在序列表达式中以达到强制使用间接调用eval的目的<br>2.尽可能间接地调用eval函数，而不要直接调用eval函数。</p>
<p>#理解函数调用、方法调用及构造函数调用之间的不同<br>1.方法调用将被查找方法属性的对象作为调用接受者。<br>2.函数调用将全局对象（处于严格模式下则为undefined）作为其接收者。一般很少使用函数调用语法来调用方法。<br>3.构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/04/13/设计模式读后感/">
  <time datetime="2016-04-13T15:04:38.000Z">
    2016-04-13
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/04/13/设计模式读后感/">设计模式读后感</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#“组合优于继承！！！”</p>
<p>##Facade（门面）模式：<br>意图：希望简化原有系统的使用方式。需要定义自己的借口。<br>问题：只需要使用某个复杂系统的子集，或者需要以一种特殊的方式与系统交互。<br>解决方案： facade为原有系统的客户提供了一个新的接口。<br>参与者与协作者：为客户提供的一个简化接口，使系统更容易使用。<br>效果：facade模式简化了对象所需子系统的使用过程。但是，由于facade并不完整，因此客户可能无法使用某些功能。<br>实现： 定义一个或多个具备所需接口的新类。<br>      让新的类使用原有的系统。<br>感悟：就是把原先的多个接口所返回的数据用一个新的类包装起来，在新类中可以对这些数据进行整合。使其能够被更方便的运用。</p>
<hr>
<p>##Adapter（适配者）模式：<br>意图：是控制范围外的一个原有对象与某个接口匹配。<br>问题：系统的数据和行为都正确，单接口不服。通常用于必须从抽象类派生时。<br>解决方案：Adapter模式提供了具有所需接口的包装类。<br>参与者与协作者：Adapter改变了Adaptee的接口，使Adaptee与Adapter的基础类型Target匹配。<br>这样用户就可以使用Adaptee了，好像它是Target类型。<br>效果：Adapter模式使原有对象能够适应新的类结构，不受其接口的限制。<br>实现：将原有的类包含在另一个类之中。让曝韩磊与需要的接口匹配，调用被包容类的方法。<br>感悟：就是原有的接口所返回的数据可能是有冗余或者格式不符合使用者的要求，这时候就需要建立一个中间层，来把这些数据进行适当的转换。</p>
<hr>
<p>##Strategy（策略）模式：<br>意图：可以根据所处上下文，使用不同的业务规则或算法。<br>问题：对所需算法的选择取决于发出请求的客户或者要处理的数据。如果只有一些不会变化的算法，就不需要strategy模式。<br>解决方案： 将对算法的选择和算法的实现相分离。允许根据上下文进行选择。<br>参与者与协作者： strategy制定了如何使用不同的算法。<br>                各个ConcreteStrategy实现了这些不同的算法。<br>                Context 通过类型为Strategy的引用使用具体的Concrete-strategy。strategy与context相互作用以实现所选的算法<br>                （有时候strategy必须查询context）。context将来自client的请求转发给strategy。<br>效果： strategy模式定义了一系列的算法。<br>      可以不使用switch语句或条件语句。<br>      必须以相同的方式调用所有的算法（他们必须拥有相同的接口）。各concretestrategy与context之间的相互作用可能需要在context中加入获取<br>      状态的方法。<br>实现： 让实用算法的类（context）包含一个抽象类（strategy），该抽象类有一个抽吸那个方法指定如何调用算法，每个派生类氨溴要实现算法。注意，在圆形strategy<br>模式中，选择所用具体实现的职责由client对象承担，并转给strategy模式的context对象。<br>感悟： 有点像后面所说的工厂模式，只不过工厂模式是用来创造所需对象，而策略模式则是返回对应的算法；工厂模式是创建型模式，策略模式是行为型模式。<br>其更关注行为的封装，追求的时返回的值。</p>
<hr>
<p>##Bridge模式：<br>意图：将一组实现与另一组使用它们的对象分离。<br>问题：一个抽象类的派生类必须使用多个实现，单不能出现类数量爆炸性增长。<br>解决方案： 为所有事先定义一个接口，供抽象类的所有派生类使用。<br>参与者与协作者: Abstraction 为要实现的对象定义接口，implementor为具体的实现类定义接口。abstraction的派生类使用Implement的<br>派生类，却无需知道自己具体使用哪一个concreteimplementor。<br>效果： 实现与使用实现的对象解耦，提供了可扩展性，客户对象无需操心实现问题。<br>实现：将实现封装在一个抽象类中。<br>     在要实现的抽象的基类中包含一个实现的句柄。注意：在Java中，你可以在实现中使用接口来代替抽象类。<br>感悟：把具体实现跟其抽象类分离，这样子就能使得具体实现在其他场合的时候能够轻易的使用其他的抽象类。</p>
<hr>
<p>##Abstract Factory模式<br>意图 需要为特定的客户（或情况 提供对象组。<br>问题 需要实例化一组相关的对象<br>解决方案 协调对象组的创建。提供一种方式，将如何执行对象实例化的规则从使用这些对象的客户对象提取出来。<br>参与者与协作者 AbstractFactory为如何创建对象组的每个成员定义接口。一般每个组都有独立的ConcreteFactory 进行创建。<br>效果 这个模式将 使用哪些对象 的规则与 如何使用这些对象 的逻辑分离开来。<br>实现 定义一个抽象类来制定创建那些对象。然后为每个组实现一个具体类。可以用表或文件完成同样的任务。</p>
<hr>
<p>##Decorator 模式<br>意图 动态地给一个对象添加职责<br>问题 要使用的对象将执行所需的基本功能。 但是，可能需要为这个对象将添加某些功能，这些附加功能可能发生在对象的基础功能之前或之后<br>。<br>解决方案 可以无需创建子类，而扩展一个对象的功能<br>参与者与协作者 concreteComonent让Decorator对形象为自己添加功能。有时候用ConcreteComonent的爱生类提供核心功能，在这种情况加ConcreteComonent累就不再是具体的，而是抽象的，comonentlei<br>comonent类定义了在所有这些类所使用的接口。<br>效果 所添加的功能放在小对象中。好处是可以在concretecomonent对象的功能之前或之后动态添加功能。单对象连总是终与concretecomonent对象。<br>实现 创建一个抽象类来表示原类喝药要添加到这个类的新功能。在装饰类中，将对新功能的调用放在对紧随其后对象的之后，以获得正确的顺序。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/18/div居中技巧/">
  <time datetime="2016-03-17T16:22:32.000Z">
    2016-03-18
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/18/div居中技巧/">元素居中技巧</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>首先先提供一个有趣的工具，这个工具能够很容易生成各种元素的居中代码。<br><a href="http://howtocenterincss.com/#contentType=text&amp;horizontal=center&amp;vertical=middle&amp;browser.IE=none" target="_blank" rel="external">http://howtocenterincss.com/#contentType=text&amp;horizontal=center&amp;vertical=middle&amp;browser.IE=none</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/17/HTML标签语义化概略/">
  <time datetime="2016-03-16T16:09:35.000Z">
    2016-03-17
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/17/HTML标签语义化概略/">HTML标签语义化概略</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>##详细介绍请看：<br>–<a href="http://www.ccjk.com/html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">http://www.ccjk.com/html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/</a></p>
<ol>
<li><code>&lt;article&gt;</code>  定义独立的内容，如论坛帖子、报纸文章、博客条目、用户评论等内容。</li>
<li><code>&lt;aside&gt;</code>定义两栏或多栏页面的侧边栏内容，如联系我们、客服、网站公告等内容。</li>
<li><code>&lt;audio&gt;</code>定义音频内容，如音乐或其他音频流。<br>autoplay    autoplay    自动播放。<br>controls    controls    显示控件。<br>loop    loop    自动重播。<br>preload preload 预备播放。如果使用 “autoplay”，则忽略该属性。<br>src url 音频的URL。<br>支持HTML5的全局属性和事件属性。<br>`<br>&lt;!– <audio src="”audio.wav”"><br>您的浏览器不支持 audio 标签。（注：可以在开始标签和结束标签之间加上此文本内容，这样若浏览器不支持此元素，就可以显示出这个信息。）</audio></li>
</ol>
<p> –&gt;`</p>
<ol>
<li><code>&lt;code&gt;&lt;!-- &lt;canvas&gt; --&gt;&lt;/code&gt;</code>定义图形，如图表和其他图像。（注：<canvas> 只是图形容器，我们必须使用脚本来绘制图形。）</canvas></li>
<li><code>&lt;code&gt;&lt;!-- &lt;command&gt; --&gt;&lt;/code&gt;</code>标记定义一个命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。</li>
<li><code>&lt;code&gt;&lt;!-- &lt;datalist&gt; --&gt;&lt;/code&gt;</code>定义选项列表，需与 input 元素配合使用，通过input 元素的 list 属性来绑定，用来定义 input 可能的值。datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。</li>
<li><code>&lt;code&gt;&lt;details&gt;&lt;/code&gt;</code>用于描述文档或文档某个部分的细节。</li>
<li><code>&lt;code&gt;&lt;embed&gt;&lt;/code&gt;</code>定义外部的可交互的内容或插件。</li>
<li><code>&lt;code&gt;&lt;figure&gt;&lt;/code&gt;</code>定义一组媒体内容（图像、图表、照片、代码等）以及它们的标题。如果被删除，则不应对文档流产生影响。</li>
<li><code>&lt;code&gt;&lt;footer&gt;&lt;/code&gt;</code>定义一个页面或一个区域的页脚。可包含文档的作者姓名、创作日期或者联系信息。</li>
<li><code>&lt;code&gt;&lt;header&gt;&lt;/code&gt;</code>定义一个页面或一个区域的头部。</li>
<li><code>&lt;code&gt;&lt;hgroup&gt;&lt;/code&gt;</code>定义文件中一个区块的相关信息，使用 <hgroup> 标签对网页或区段（section）的标题进行组合。</hgroup></li>
<li><code>&lt;code&gt;&lt;keygen&gt;&lt;/code&gt;</code>定义表单里一个生成的键值。规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。</li>
<li><code>&lt;code&gt;&lt;mark&gt;&lt;/code&gt;</code>定义有标记的文本。请在需要突出显示文本时使用此标签。</li>
<li><code>&lt;code&gt;&lt;meter&gt;&lt;/code&gt;</code>定义度量衡。仅用于已知最大和最小值的度量。（注：必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。）</li>
<li><code>&lt;code&gt;&lt;nav&gt;&lt;/code&gt;</code>定义导航链接。（注：如果文档中有“前后”按钮，则应该把它放到 <nav> 元素中。）</nav></li>
<li><code>&lt;code&gt;&lt;output&gt;&lt;/code&gt;</code>定义不同类型的输出，比如脚本的输出。</li>
<li><code>&lt;code&gt;&lt;progress&gt;&lt;/code&gt;</code>定义任务（如下载）的过程，可以使用此标签来显示 JavaScript 中耗费时间的函数的进度。</li>
<li><code>&lt;code&gt;&lt;section&gt;&lt;/code&gt;</code>定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</li>
<li><code>&lt;code&gt;&lt;source&gt;&lt;/code&gt;</code>为媒介元素（比如 <video> 和 <audio>）定义媒介资源。</audio></video></li>
<li><code>&lt;code&gt;&lt;time&gt;&lt;/code&gt;</code>定义一个日期/时间，该元素能够以机器可读的方式对日期和时间进行编码，举例说，用户代理能够把生日提醒或排定的事件添加到用户日程表中，搜索引擎也能够生成更智能的搜索结果。</li>
<li><code>&lt;code&gt;&lt;address&gt;&lt;/code&gt;</code> 表明作者的名字等详细信息</li>
<li><code>&lt;code&gt;&lt;legend&gt;&lt;/code&gt;</code>表单的标题</li>
<li><code>&lt;code&gt;&lt;fieldset&gt;&lt;/code&gt;</code>带标题的表单框要配合legend使用</li>
<li><code>&lt;code&gt;&lt;tbody&gt;&lt;tfoot&gt;&lt;/code&gt;</code>表格的时候使用，搭配th来表明表格的表头，身体，尾部</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/15/gulp的使用方法/">
  <time datetime="2016-03-15T15:40:24.000Z">
    2016-03-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/15/gulp的使用方法/">gulp的使用方法</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>基本用法<br>// gulpfile.js<br>gulp.task(‘foo’, function() {<br>    gulp.src(glob)<br>        .pipe(…)<br>        .pipe(…)<br>        .pipe(gulp.dest(…))<br>        .pipe(…)<br>        .pipe(gulp.dest(…))<br>});</p>
<p>// shell<br>$ gulp foo<br>基本 API<br>gulp.src(glob[, options])<br>根据 glob 匹配文件，返回 stream，可以通过 .pipe() 方法传递给后续的插件。<br>gulp.dest(path[, options])<br>一般用法 .pipe(gulp.dest(path))，把 pipe 中的内容按照指定的 path 写成文件，会自动创建不存在的文件夹。<br>注意，可以通过 .pipe 多次指定输出的地方，具体请看 这里<br>gulp.task(name[, deps], fn)<br>定义名为 name 的任务，定义之后就可以在命令行中使用 gulp xxx 来执行任务。<br>deps 里面的任务全部完成后才会执行 fn<br>deps 里面的任务都是并行执行的，如果需要顺序执行，需要特殊写法。具体看 这里<br>gulp.watch(glob[, opts, cb])<br>监听文件变化<br>不会监听新文件（目录），所以一般你会需要 gulp-watch<br>常用命令 （自定义）</p>
<h1 id="for_development_mode">for development mode</h1><p>gulp server</p>
<h1 id="run_test">run test</h1><p>gulp test</p>
<h1 id="for_production_mode">for production mode</h1><p>gulp build<br>gulp server 流程<br>把 less, sass, 之类的文件编译成 CSS，常用插件：<br>gulp-less<br>gulp-sass<br>创建 Web Server (with Live Reload)，常用：<br>gulp-connect，用来创建 Web Server，其实还有其他选择的，但多数都是利用 connect 来创建 Web Server 的。<br>node-proxy-middle，用来代理请求，可以把 /api/xxx 发送到指定的地址。(常用于 SPA 开发)<br>connect-modrewrite，匹配资源，如果不匹配就可以重定向到指定地址。(常用于 SPA 开发)<br>connect-history-api-fallback，作用同上，也用于匹配资源，但用起来简单很多。(常用于 SPA 开发)<br>监听文件变化，常用插件：<br>gulp-watch<br>示例代码<br>    gulp.task(‘clean:css’, function () {<br>        del.sync(‘app/styles/*.css’);<br>    });</p>
<pre><code>gulp.task(<span class="string">'less'</span>, [<span class="string">'clean:css'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">var</span> stream = gulp
            .src(<span class="string">'app/styles/main.less'</span>)
            .pipe(less())
            .pipe(gulp.dest(<span class="string">'app/styles/'</span>));
    <span class="keyword">return</span> stream;
});

gulp.task(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    connect.server({
        root: <span class="string">'./app'</span>,
        port: <span class="number">9000</span>,
        livereload: <span class="literal">true</span>,
        middleware: <span class="function"><span class="keyword">function</span> (<span class="params">connect, o</span>) </span>{
            <span class="keyword">return</span> [
                (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
                    <span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);
                    <span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'proxy-middleware'</span>);
                    <span class="keyword">var</span> options = url.parse(<span class="string">'http://localhost:3000/api'</span>);
                    options.route = <span class="string">'/api'</span>;
                    <span class="keyword">return</span> proxy(options);
                })(),
                modRewrite([
                    <span class="string">'!\\.html|\\.js|\\.css|\\.swf|\\.jp(e?)g|\\.png|\\.gif|\\.eot|\\.woff|\\.ttf|\\.svg$ /index.html'</span>
                ])
            ];
        }
    });
});

gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    gulp
        .src(<span class="string">'app/styles/**/*.less'</span>, {read: <span class="literal">false</span>})
        .pipe(watch(<span class="string">'app/styles/**/*.less'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
            <span class="keyword">return</span> gulp
                .src(<span class="string">'app/styles/main.less'</span>)
                .pipe(less())
                .pipe(gulp.dest(<span class="string">'app/styles/'</span>))
                .pipe(connect.reload());
        }));

gulp
    .src([<span class="string">'app/scripts/**/*.js'</span>, <span class="string">'app/**/*.html'</span>])
    .pipe(watch([<span class="string">'app/scripts/**/*.js'</span>, <span class="string">'app/**/*.html'</span>]))
    .pipe(plumber())
    .pipe(connect.reload());
});

gulp.task(<span class="string">'server'</span>, [<span class="string">'less'</span>, <span class="string">'connect'</span>, <span class="string">'watch'</span>]);
gulp build 流程
清理 dist/ 文件夹
del，根据 glob 来删除文件/目录
压缩文件
gulp-htmlmin，压缩 html 文件
gulp-minify-html，同上
gulp-cssmin，压缩 css 文件
gulp-minify-css，同上，封装了 clean-css，star 比上面的多
gulp-uglify，混淆 JavaScript 代码
gulp-usemin，合并指定 block 中的文件
gulp-rev，给静态文件加上版本号，如 app.js -&gt; app-d41d8cd98f.js
复制其他文件到 dist/
gulp.src(...).pipe(gulp.dest(...))
实例代码
gulp.task(<span class="string">'clean:build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    del.sync(<span class="string">'dist/'</span>, {force: <span class="literal">true</span>});
});

gulp.task(<span class="string">'minify'</span>, [<span class="string">'clean:build'</span>, <span class="string">'less'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    gulp
        .src(<span class="string">'app/views/**/*.html'</span>)
        .pipe(htmlmin({collapseWhitespace: <span class="literal">true</span>}))
        .pipe(gulp.dest(<span class="string">'dist/views'</span>));

    gulp
        .src(<span class="string">'app/index.html'</span>)
        .pipe(usemin({
            js: [uglify(), rev()],
            css: [minifyCss(), <span class="string">'concat'</span>, rev()]
        }))
        .pipe(gulp.dest(<span class="string">'dist/'</span>));
});

gulp.task(<span class="string">'copyfonts'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    gulp
        .src(<span class="string">'app/styles/fonts/*'</span>)
        .pipe(gulp.dest(<span class="string">'dist/fonts/'</span>));
});

gulp.task(<span class="string">'build'</span>, [<span class="string">'clean:build'</span>, <span class="string">'minify'</span>, <span class="string">'copyfonts'</span>]);
</code></pre><p>转载自 scarlex 的文章 利用gulp处理前端工作流程 </p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/14/创建六边形div/">
  <time datetime="2016-03-14T15:41:26.000Z">
    2016-03-14
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/14/创建六边形div/">创建六边形div</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#如何创建一个六边形的div<br>要创建一个六边形的div就要求使用到CSS3<br>中的旋转属性。六边形的div可以被分解为3个矩形重叠而成。<br><img src="../img/1.png" alt=""><br>通过图片可以发现，由于div之间的层叠遮挡关系，实际上能展示出来的区域<br>只有大概其中的1/2。<br><img src="../img/2.png" alt=""><br>所以在设置div的大笑的时候首先，要比预计的六边形要大2倍。第二长宽比要保证是在4:3否则便就对不齐了。<br>当前提都做好后，就要开始应用旋转了。通过计算得出，每两个矩形div之间要形成60度的夹角。</p>
<pre><code>
    transform: rotate(120deg);
</code></pre>
在使用css3时记住要进行兼容性检查，通过添加-webkit-等后缀避免页面出错。
继续话题，如果3个div是各自独立的话，那么可以想象出在最表面的那个div会不受限制，把其中的所有内容都展现出来，为了解决这个问题，就要将这些div嵌套起来。
<pre><code>
        <div class="box box-first ">
                        <div class="boxF">
                            <div class="boxS">
                                <div class="boxT ">
                                    <div class="border borderF "></div>
                                    <div class="border borderS "></div>
                                    <div class="border borderT "></div>
                                    <img src="" style="height: 100%;" class="blur background">
                                    <div class="overlay col-xs-3">
                                        <a href="#"></a>
                                    </div>

                                </div>
                            </div>
                        </div>
</div></code></pre>
通过嵌套的div+css设置为overflow：hidden，就能起到了父div在一个方向上限制子div的内容展现。从而达成最内部的div只能显示为一个6边形。
PS。为了帮div设置边框也是在耗费了一定的时间，由于是通过各div间互相制约制作的，所以要帮其添加边框就不能够采取直接在div上添加border属性，只能够在其内部另外在设置3个只有短边有border的div来形成边框效果。
css：<pre><code>
       .clear {
                clear: both;
            }

            .background {
                display: inline-block;
            }

            .box {
                float: left;
                z-index: 6;
                display: none;
            }

            .lineF,
            .lineS {
                position: absolute;
                visibility: visible;
                z-index: 5;
            }

            .box-first,
            .box-second {
                margin-left: -webkit-calc(50% - 300px);
                margin-left: -moz-calc(50% - 300px);
                margin-left: calc(50% - 300px);
            }

            .boxMore {
                margin-left: -webkit-calc(50% - 200px);
                margin-left: -moz-calc(50% - 200px);
                margin-left: calc(50% - 200px);
            }

            .lineS {
                top: 172px;
                left: 116px;
            }

            .boxF,
            .boxS,
            .boxT,
            .overlay {
                width: 200px;
                height: 250px;
                overflow: hidden;
            }

            .boxF,
            .boxS {
                visibility: hidden;
            }

            .boxF {
                transform: rotate(120deg);
                float: left;
                margin-left: 0px;
                -ms-transform: rotate(120deg);
                -moz-transform: rotate(120deg);
                -webkit-transform: rotate(120deg);
            }

            .boxS {
                transform: rotate(-60deg);
                -ms-transform: rotate(-60deg);
                -moz-transform: rotate(-60deg);
                -webkit-transform: rotate(-60deg);
            }

            .boxT {
                transform: rotate(-60deg);
                background: no-repeat 50% center;
                background-size: cover;
                -ms-transform: rotate(-60deg);
                -moz-transform: rotate(-60deg);
                -webkit-transform: rotate(-60deg);
                visibility: visible;
            }

            .overlay {
                transition: all 250ms ease-in-out 0s;
                display: inline-block;
                position: absolute;
                z-index: 7;
                text-align: center;
                top: 0px;
            }

            .overlay a {
                display: none;
                border-radius: 3px;
                line-height: 32px;
                text-decoration: none;
                color: White;
                font-size: 18px;
                font-weight: bolder;
                margin-top: 110px;
            }

            .overlay:hover a {
                color: white;
                display: inline-block;
            }

            .border {
                border-top: 0px;
                border-bottom: 0px;
                border-left: 3px solid white;
                border-right: 3px solid white;
                position: absolute;
                z-index: 6;
                width: 200px;
                height: 115px;
                top: 27%;
            }

            .borderS {
                transform: rotate(60deg);
                -ms-transform: rotate(60deg);
                -moz-transform: rotate(60deg);
                -webkit-transform: rotate(60deg);
            }

            .borderT {
                transform: rotate(120deg);
                -ms-transform: rotate(120deg);
                -moz-transform: rotate(120deg);
                -webkit-transform: rotate(120deg);
            }
</code></pre>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/11/22/js中的call和apply的作用/">
  <time datetime="2015-11-22T11:39:57.000Z">
    2015-11-22
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/11/22/js中的call和apply的作用/">js中的call和apply的作用 </a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>这两个方法都是每个函数都自带的方法，用途都是在特定的时候调用函数，同时修改this的指向，<br>避免传入参数的不正确。同时还能够对一个原本不含有某个方法的函数，调用这个方法。<br>例子：<br>    function Animal(){<br>    this.name = “Animal”;<br>    this.showName = function(){<br>        alert(this.name);<br>    }<br>    }    </p>
<pre><code>function Cat(){    
    this.name = <span class="string">"Cat"</span>;    
}    

var <span class="keyword">animal</span> = new <span class="keyword">Animal</span>();    
var cat = new Cat();    

//输入结果为<span class="string">"Cat"</span>    
<span class="keyword">animal</span>.showName.call(cat,<span class="string">","</span>);    
//<span class="keyword">animal</span>.showName.apply(cat,<span class="comment">[]</span>);  
</code></pre><p>在这里，通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。<br>而且还能实现继承。<br>例子：<br>      function Animal(name){<br>        this.name = name;<br>        this.showName = function(){<br>            alert(this.name);<br>        }<br>    }      </p>
<pre><code>function Cat(name){    
    <span class="keyword">Animal</span>.call(this, name);    
}      

var cat = new Cat(<span class="string">"Black Cat"</span>);     
cat.showName();
</code></pre><p> Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么 Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了.<br>区别：apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。<br>call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/10/22/css-hack效果/">
  <time datetime="2015-10-22T14:51:59.000Z">
    2015-10-22
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/10/22/css-hack效果/">css hack效果</a></h1>
  

  </header>
  
  <div class="entry">
    
      <ul>
<li><a href="https://css-tricks.com/examples/ShapesOfCSS/" target="_blank" rel="external">https://css-tricks.com/examples/ShapesOfCSS/</a></li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/09/24/《H5核心技术》梗概/">
  <time datetime="2015-09-24T08:39:41.000Z">
    2015-09-24
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/09/24/《H5核心技术》梗概/">《H5核心技术》梗概</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>##canvas画布<br>画布的大小不要用css调整，一定要在标签中定义，否则会导致缩放问题。</p>
<hr>
<p>##由canvas创建一幅可另存为到本地的图片<br>利用<code>toDataURL()</code>接口，向网页中加入一个不可见的图像元素，有id值但是没有src属性。用css调整图像的位置与大小，让其覆盖在canvas上，提供<br>截图按钮。要截图的时候，用该接口向img的src提供值，同时img变可见，隐藏canvas。</p>
<hr>
<p>##创建离屏canvas<br>优势，把背景存放在<code>display:none</code>的canvas中提高动画的运行效率。</p>
<hr>
<p>##渐变色与图案<br><code>createLinearGradient()</code>(线性)和<code>createRadialGradient()</code>(放射性)中的addcolorstop即可设置颜色停止点在渐变线上的位置。</p>
<hr>
<p>##路径的闭合<br>要用beginpath()或者clearRect()来清除路径，否则rect()，lineTO()新开的路径会自动连接到上一次创建的路径的末端。用closePath则可以吧<br>有缺口的路径自动进行闭合。arc()方法默认以逆时针来进行绘制路径，arcTo()可以画一段圆角，以所给的两个点以及画的圆角的半径来作为参数。而在进行fill()的时候<br>路径会自动闭合而且会以逆时针的方式顺着线，然后在左边进行填充。</p>
<hr>
<p>##剪辑区域制作动画<br>利用clip()来调整需要剪辑的区域，然后使用clearRect()来清除掉内容。注意：调用clip()的时候记住要用save()和restore()来包裹住<br>他，否则由于clip()具有把剪辑区域设置为当前剪辑区域与当前路径的交集，那么剪辑区域会变得越来越小，而这是无法改变的。</p>
<hr>
<p>##文本编辑<br>文本编辑的时候光标的位置不要用measureText()来确定位置，因为这样只是测量了文本的宽度，而事实上用fillText()来渲染的时候可能会超出<br>文本的宽度。而在需要精确文本坐标的时候（要实现橡皮擦，删除文字的时候），最好是把该区域用clip()直接把整个区域的内容都擦除。</p>
<hr>
<p>##图像绘制的安全问题<br>canvas会通过设置origin-clean的标志位，如果用过drawImage()的话这个标志位就会变成false，在再次调用<code>toDataURL()</code>的时候就会出错。<br>而且为了防止网页中的恶意代码会篡改本地的文件系统，浏览器会把用户的文件系统与运行程序环境进行隔离，而在开发的时候可以通过设置在命令行中<br>以“–allow-file-access-from-files”参数来启动chrome浏览器让其绕开绘图安全机制。</p>
<hr>
<p>##性能对比</p>
<p>###使用getImageData()和drawImageData()时<br>1.不要频繁的使用getImageData()来获取少量数据，这样会使网页加载缓慢。<br>2.避免在循环体内直接访问对象的属性而应该将其存在局部变量中。<br>3.应该是用循环计数器来遍历完整的像素，而不是像素分量（红绿蓝，Alpha）。<br>4.不必使用逆向遍历和移位技巧。</p>
<hr>
<p>##绘制动画<br>通过使用“polyfill”方法（即另外写一个实现动画函数其中要包括（requestAnimationFrame||window.webkitRequestAnimationFrame||<br>window.mozRequestAnimationFrame||window.MsRequestAnimationFrame||一个使用settimeout的函数））来实现动画，这样才能避免由于浏览器兼容性问题。<br>浏览器会自动使用双缓冲区模式来绘制动画，所以不要重复手动创建一个所有内容都重新绘制的缓冲区。但是，在一些小部件上使用多重缓冲区依然能够使效率得到提升。</p>
<hr>
<p>##碰撞检测<br>外界矩形判别法，即两个凸多边形的话从每条边上作发现为投影轴，检测每个多边形在投影轴上的投影是否有分离，如有分离则未碰撞。<br>外界圆判别法，直接计算圆心距。<br>最小平移法：直接求定点到边的最小距离。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/09/20/浏览器类型检测方法/">
  <time datetime="2015-09-20T12:43:18.000Z">
    2015-09-20
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/09/20/浏览器类型检测方法/">浏览器类型检测方法</a></h1>
  

  </header>
  
  <div class="entry">
    
      
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
    <a href="/page/2/" class="next">下一页</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2016 <a href="/">kyjo2014</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>