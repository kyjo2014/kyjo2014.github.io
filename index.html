<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>LTH&#39;s note book</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="kyjo2014">
  
  
  <meta name="description" content="html|css|javascript|LTH&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LTH's note book">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LTH's note book">
<meta property="og:description" content="html|css|javascript|LTH&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LTH's note book">
<meta name="twitter:description" content="html|css|javascript|LTH&apos;s blog">
  
    <link rel="alternate" href="/atom.xml" title="LTH&#39;s note book" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">LTH&#39;s note book</a></h1>
    <p><a href="/">逗逼+未来の程序员</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/Reading">Reading</a></li>
      
        <li><a href="/about">About</a></li>
      
        <li><a href="/testing">TestArea</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/03/12/vue双向数据绑定/">
  <time datetime="2017-03-12T15:47:55.000Z">
    2017-03-12
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/03/12/vue双向数据绑定/">vue双向数据绑定</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p> #Vue双向数据绑定<br> 最近在学习vue源码，vue最核心的理念就是实现了MVVM模型下的视图层（view）与 视图模型层（ViewModel）的数据绑定。vue是通过三个步骤做到的</p>
<ol>
<li>监视数据变化<br>实现监视数据，马上就想到了使用ES5新增的Object.defineProperty()，使用这个接口能够方便的为对象中的各个属性定义一个setter和getter函数。每当对对象中的某个属性进行操作的时候，就会自动触发对应的setter或者getter函数</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/03/08/UC实习面试/">
  <time datetime="2017-03-08T08:05:36.000Z">
    2017-03-08
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/03/08/UC实习面试/">UC实习面试</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="UC实习生面试"><a href="#UC实习生面试" class="headerlink" title="UC实习生面试"></a>UC实习生面试</h1><h4 id="下面将会分三个部分总结这次面试"><a href="#下面将会分三个部分总结这次面试" class="headerlink" title="下面将会分三个部分总结这次面试"></a>下面将会分三个部分总结这次面试</h4><ol>
<li>准备面试</li>
<li>面试过程</li>
<li>总结经验</li>
</ol>
<h2 id="准备面试"><a href="#准备面试" class="headerlink" title="准备面试"></a>准备面试</h2><p>在把简历发给师兄内推后第二天，HR小姐姐已经直接打电话到手机，询问预约面试的时间。<br>注意：</p>
<ol>
<li>在获得内推后的2~3天内一定要保持手机畅通，看到陌生电话也要接，因为有时候<br>打来的电话会被标记为骚扰电话。</li>
<li>需要询问去面试是否需要自己打印简历。</li>
</ol>
<hr>
<p>一开始约的是周五下午进行面试，但是由于面试官临时有紧急会议，所以面试推迟到了下周一<br>约了下午3点半去面试，3点就去到。先在下面稳定下自己的心情，由于之前已经去过UC大厦，清楚从哪里上楼。免去因为找不到电梯而慌张。等到差不多3点15分，就上去面试了。</p>
<p>上楼后，由于会议室正有其他人在面试，就坐在外面等了十分钟左右。正好可以观摩下面试是个怎么样的流程。(hhh面试官看起来还挺和蔼的。) 过了一会，hr说先要进行一份笔试就带着去到一个休息室的地方去做题。面试正式开始lol</p>
<p>##面试过程</p>
<ol>
<li><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><ol>
<li><h4 id="css基础"><a href="#css基础" class="headerlink" title="css基础"></a>css基础</h4>主要作用：考察面试者对css各属性的熟悉程度，以及有没有对css3新增属性有所了解<br>题目： 请写出position 的各个值和定位原点</li>
<li><h4 id="页面经典布局"><a href="#页面经典布局" class="headerlink" title="页面经典布局"></a>页面经典布局</h4>双飞翼，圣杯布局的实现。<br>题目： 请写出实现两边等宽，中间自适应宽度的布局的方案（越多越好）  </li>
<li><h4 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h4> 考察对js基本api在提供不同参数下的结果理解。声明提前，作用域，this的指向。<br> 这里大坑：居然忘记了parseInt最后一个参数是进制</li>
<li><h4 id="JavaScript进阶"><a href="#JavaScript进阶" class="headerlink" title="JavaScript进阶"></a>JavaScript进阶</h4> 考察对闭包的理解。</li>
<li><h4 id="思维拓展"><a href="#思维拓展" class="headerlink" title="思维拓展"></a>思维拓展</h4>如何计算时钟中的分针和时针的角度</li>
<li><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4>写出你所知道的排序算法。<br>注意：要留心笔试时间，只有半个小时。布局那题写太多了，结果后面都没有什么时间做，草草写了。 </li>
</ol>
</li>
</ol>
<hr>
<ol>
<li>面试<br> 面试官看了下卷子，就开始根据题目来问问题。  <ol>
<li>position：sticky是什么属性？<br>css3新增加的属性，特性是在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。</li>
</ol>
</li>
</ol>
<pre><code>2. 你写的这些布局方式，有什么是基于什么原理实现的，有什么优缺点。  
    这里就从浮动，计算属性，flex布局等情况解释，然后说浏览器兼容性，加载速度，三列等高。


3. 为什么这几道题目输出是这个结果。
    1. parseInt 的最后一个参数是什么？ 
       成功答错，在接下来的追问中丢盔卸甲。 

    2. NaN 和 null 、undefined 的关系  
        NaN ！= null  
        NaN ！= undefined  
        null == undefined
    3. 函数表达式和函数声明的不同    
        函数表达式中的匿名函数声明提前但因为赋值是不会提前所以提前使用会报错。
        函数声明整体提前所以提前使用不会报错。 
        （当时讲得太长了，就不打出来了，答案上网搜搜就有）
    4. 如何解决闭包导致的内存泄漏         
        可以看[这篇文章](http://blog.csdn.net/liangklfang/article/details/48543917)
    5. 讲一下各种排序算法的原理，时间和空间复杂度。  
       可以看[这篇文章](http://blog.csdn.net/m372897500/article/details/51478111)
    6. 讲一下递归栈是如何保存数据的？什么是尾递归优化？
        进入递归会把当前需要使用的变量和返回地址保存在一个帧中，每进行一次递归，就会生成一个这样的帧在内存中以栈的方式保存下来。尾递归优化是指，所有方法中的局部变量都已经计算完毕。所以下一个帧可以直接替换掉上一个帧。

4. 请解释下Jquery.ready()函数如何实现
  其实是个‘ployfill’,解决了在不同浏览器下onload事件有不同实现的问题。  

5. http状态码304是什么意思？  
   ‘not modified’ 当浏览器检测到资源存在缓存时向服务器进行查询，如果缓存新鲜度足够高，服务器就会返回304。
6. http状态码301、302是什么意思？  
   301是永久重定向，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。 302是暂时重定向，抓取新的内容而保存旧的网址。
7. 有了解过SEO吗？  
    “搜索引擎优化”，通过为页面增加元数据标签，关键字，友好链接，语义化标签等，使得网站在搜索引擎上的排名提升。
8. 301、302对SEO有什么影响吗？  
   当时只记得302会导致SEO评分降低。原理没有了解清楚，面试官不是很满意这里。
9. 说一下浏览器的渲染过程？  
    刚好之前看过《webkit技术内幕》，就从tcp的三次握手开始-&gt;DOM树-&gt;renderObject树
    。。。一直讲。
10. 有没有接触过node  
    有，入门级，使用过express进行开发。
11. 如何看待前端目前的形势  
   技术快速迭代，风险与机遇并存。
12. 接着上一个问题，为什么？  
   从微信小程序的热潮和爆冷开始聊。谈到前端快速的技术迭代对参加工作的要求。    

13. 接下来让我问他问题。 
    于是就问了在大公司是如何进行项目的测试，以及前端和后台职责的区分。

面试官表示他的问题问完了，但是要等下。然后又叫了另外一名面试官过来继续问问题。（懵逼，这算是两次面试吗？） 
</code></pre><hr>
<pre><code>第二名面试官：
1. 了解面向对象编程吗？
    面向对象编程是让程序能够由单个小单元组合而成，增加程序的灵活性、可重用性和扩展性。

2. JavaScript如何实现继承
    类式继承，原型继承，组合式继承，寄生式继承，寄生组合式继承(具体解释)

3. 如何获得内推信息？
    从师兄处获得
4. 广工来面的挺多的，你觉得你的水平处在什么阶段？
    我觉得自己处于中等水平，目前缺失的方面主要是对于框架思想了解不足，没有深入学习源码。在编写代码的时候没有很好考虑到如何降低程序耦合度........
5. 平时有什么兴趣爱好？
    拍照，旅游，看动漫，打羽毛球
6. 什么时候有时间实习？一周能够过来几天？
    因为平时还有课程，能够过来3天，如果可以的话明天就可以（笑）
    注：这里面试官不是很满意，大概表示的意思是来的天数太少，做不了多少东西。。。。或许下次应该说整个星期？
7. 有什么问题想问吗？
    面试什么时候会出结果？
    面试官：由于不是校招，结果估计会在2-3个星期左右出，考虑到现在你们没有那么多时间实习，可能会在4月中再召集一次面试（wtf），到时候hr会以短信方式通知。
</code></pre><hr>
<pre><code>历时2个半小时的面试到这里就结束了,这次面试暴露出自己深度不足的缺陷，同时缺乏对话题的导向作用。之前准备了的ES6，webpack，vue，设计模式等知识没有在面试中展现出来，而对于基础算法理解不够深入，不能够一下反应出答案。同时可以看出实习对时间要求高。因此，无论结果如何，这次面试就先当作积累经验吧。
</code></pre>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/10/10/《web之变》读书笔记/">
  <time datetime="2016-10-10T15:55:37.000Z">
    2016-10-10
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/10/10/《web之变》读书笔记/">《web之变》读书笔记</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#rules</p>
<p>##浏览器内核种类</p>
<p>###布局引擎<br>1.微软的Trident<br>    IE<br>2.基于开源项目的Webkit浏览器<br>    桌面端Safari、IOS端Safari、旧版Chrome、安卓默认浏览器、黑莓设备、微软收购前的诺基亚设备、<br>    PS3/4中的浏览器。<br>3.基于Blink开源项目的浏览器<br>    最新版本的chrome和opera的布局引擎<br>4.Mozilla的Gecko<br>    firefox的内核</p>
<p>###Js解释引擎</p>
<p>1.chakra<br>    IE<br>2.squirrelfish extreme/nitro<br>    webkit的Js引擎<br>3.V8<br>    chrome和基于blink的oprea，node.Js的解释引擎<br>    有点在执行前将js编译为原生代码的js引擎，性能明显提升。<br>4.spidermonkey<br>    firefox的内核</p>
<p>##分析受众</p>
<p>###了解受众使用的浏览器<br>利用<a><a href="http://caniuse.com" target="_blank" rel="external">http://caniuse.com</a></a>对浏览器进行支持性查询。</p>
<p>###专注于最优，而不是绝对的解决方案<br>检测用户所处环境，给予在不同环境下最好的解决方案。如在wifi环境下<br>给予用户最清晰的图片和完美的动态效果。而在计时收费设备上所能看到的仅仅是一个logo和<br>无序列表</p>
<p>###拥抱可访问性<br>确保残障人士也可以使用web，通过提供音频或者视频替代内容。<br>具体例子参（<a><a href="http://bit.ly/uw-accessibility" target="_blank" rel="external">http://bit.ly/uw-accessibility</a></a> </p>
<p>###为非文字的内容提供可替代的文本<br>查看<a><a href="http://bit.ly/uw-alt-text" target="_blank" rel="external">http://bit.ly/uw-alt-text</a></a><br>注意！旧版安卓浏览器不会显示img标签中的title值或者替换文本</p>
<p>###确保信息和结构与表现的分离<br>利用<a href="http://bit.ly/uw-html5-outliner" target="_blank" rel="external">http://bit.ly/uw-html5-outliner</a> 检测缩写网页的结构，如果看起来像一份很好的目录就可以了。</p>
<p>###确保可以用键盘进行所有功能性操作</p>
<p>###除非必须的定时或移动，否则用户应当可以暂停内容。</p>
<p>###提供机制帮助用户找到内容、定位位置和导航页面</p>
<p>###帮助用户避免犯错，以及让纠正错误变得简单</p>
<p>###为现在和未来的UA提供兼容（包括辅助技术）</p>
<p>##利用modernizr进行浏览器特征检测<br>modernizr库包含了许多不同插件用以检测浏览器的兼容性<br>但是注意！有些特征是不可检测的，例如modernizer-touch插件并不可以<br>用来测试用户是使用鼠标还是触屏，只能检测touch*系列的事件是否存在。</p>
<p>##响应式设计与移动端体验设计</p>
<p>###判断响应式设计是否真的适合所有的网站？<br>解决方案：<br>1.移动端优先<br>    设计与开发时优先考虑移动端的体验，采用渐进增强的方式去支持PC端</p>
<p>2.RESS（服务器端组建的响应式设计）</p>
<p>各方案优缺点分析<br>响应式设计：<br>好处：简化服务器端、更容易维护、降低应用的整体复杂性、只提供一个入口给搜索引擎、能够支持未知设备<br>缺点：性能差、代码冗余、限制应用的复杂性</p>
<p>专用的移动端站点<br>优点：可以针对具体设备做性能优化、提高应用程序的灵活性<br>缺点：使服务器端变得更复杂、不利于维护、搜索引擎方面的缺陷、链接难以管理（不同页面跳转）<br>可能会兼容不到一些新的设备、用来检测并判断设备的用户代理很可能是伪造的。</p>
<p>###用重定向解决逻辑问题<br>把桌面站点与移动端URL用重定向的方式，方便用户输入<br>在页面添加一个可被点击的句柄让用户手动跳转到移动站点、并在Sessionstorage中添加一个标志位，<br>用来记录用户选择了移动站点接着是跳转代码。同时在页面中应该用正则表达式去检测用户的UA</p>
<p>###总是在你的移动站点上提供一个出口<br>能够让用户在合适的时候自由选择浏览桌面or移动端</p>
<p>###尽可能保持流体设计<br>多运用flex布局</p>
<p>###不要吝啬于是用断点<br>css媒体查询的时候用em作为单位，尽量多设置断点提供匹配常用尺寸</p>
<p>###使用相对单位<br>em，rem，vh，vw</p>
<p>##处理用户输入</p>
<p>###不要对用户进行猜测<br> 用户可能同时是鼠标+触摸的使用者</p>
<p>###为所有界面提供触摸功能<br>    iphone标准触摸尺寸是44像素</p>
<h3 id="别依赖hover提供效果"><a href="#别依赖hover提供效果" class="headerlink" title="别依赖hover提供效果"></a>别依赖hover提供效果</h3><h3 id="模拟的click时间有300ms的延迟"><a href="#模拟的click时间有300ms的延迟" class="headerlink" title="模拟的click时间有300ms的延迟"></a>模拟的click时间有300ms的延迟</h3><p>解决方法：<br>1、如果页面不能被用户缩放、浏览器将取消这个延迟，给meta标签的viewport添加user-scalable=no<br>2、同时绑定click和touchstart事件，而且在调用的函数重要使用preventDefault阻止事件被多次触发。</p>
<p>###处理*move事件<br>解决方案：<br>1.用e.clientY和e.client.X定位触摸点</p>
<p>###pointer事件：一个事件模型囊括了鼠标、触摸以及其他<br>    未被良好的支持</p>
<p>##出其复杂的Web图片</p>
<p>###提供尽可能小的文件尺寸</p>
<p>###利用浏览器的预加载</p>
<p>###为各种分辨率提供尺寸合适的图片</p>
<p>###为具备多种I型昂速比的设备提供正确尺寸的图片</p>
<p>###在不同环境使用不同尺寸的图片或不同的图片</p>
<p>###使用设计断电</p>
<p>###提供正确的图片格式</p>
<p>###图片很简单，并且应该保持简单</p>
<p>##为web去优化图片</p>
<p>###使用JPEG或者渐进式JPEG</p>
<p>###GIF、PNG、SVG</p>
<p>###WEBP是个趋势但支持不好</p>
<p>###通过配置去解决问题<br>1.利用img标签的srcset属性（仅有webkit和blink支持）<br>2.利用picture元素和source标签<br>3.使用SVG</p>
<p>##极其复杂的web视频</p>
<p>###使用video元素</p>
<p>###通过flash降级<br>通过在video标签内不添加flash视频（object&gt;param+embed）同时给flashvars参数复制的方式将视频源传给Flash插件，<br>必要时对视频做格式转换，确保内容能在各种浏览器上正确播放。</p>
<p>##注意存储与编码</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/07/19/effective-JS/">
  <time datetime="2016-07-19T01:45:58.000Z">
    2016-07-19
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/07/19/effective-JS/">effective JS</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#了解你使用的JS版本<br>1.确定你的应用程序支持JS的哪些版本。<br>2.确保你使用的任何Js的特性对于应用程序将要运行的所有环境都是支持的。<br>3.总是在执行严格模式检查的环境中测试严格代码。<br>4.当心链接那些在不同严格模式下有不同预期的脚本。</p>
<p>#理解JS的浮点数<br>1.JS的数字都是双精度浮点数。<br>2.js中的证书仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型。<br>3.位运算符将数字视为32位的有符号整数。<br>4.当心浮点运算中的精度陷阱。</p>
<p>#当心隐式的强制类型转换<br>1.类型错误可能被隐式的强制转换所隐藏<br>2.重载的运算符+是进行加法运算还是字符串连接操作取决于其参数类型。<br>3.对象通过valueof方法强制转换为数字，通过toString方法强制转换为字符串。<br>4.对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串。<br>5.具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示。<br>6.测试一个值是否为未定义的值,应该使用typeof或者与undefined进行比较而不是使用真值运算。</p>
<p>#原始类型由于封装对象<br>1.当做相等比较时，原始类型的封装对象预期原是指行为不一样。<br>2.获取和设置原始类型值的属性会隐式地创建封装对象。</p>
<p>#避免对混合类型使用==运算符<br>1.当参数类型不同时， ==运算符应用了一套难以理解的隐式强制转换就能明白的比较运算。<br>2.使用===运算符，使读者不需要涉及任何的隐式强制转换就能明白你的比较运算符。<br>3.当比较不同类型的值时，使用你自己的现实强制转换是程序的行为更清晰。</p>
<p>#了解分号插入的局限</p>
<p>1.仅在“}”标记之前、一行的结束和程序的结束处推导分号。<br>2.仅在紧接着的标记不能被解析的时候推导分号。</p>
<ol>
<li>在以（、[、+、-或/字符开头的语句前绝不能省略分号。</li>
<li>当脚本链接的时候，在脚本之间显示地插入分号。<br>5.在return、throw、break\continue、或–的参数之前绝不能换行。<br>6.分号不能作为for循环的头部或空语句的分隔符而被推导出。</li>
</ol>
<p>#视字符串为16位的代码单元序列</p>
<p>1.JS字符串由16的代码单元组成，而不是由Unicode代码点组成。<br>2.js使用两个代码单元表示2^16，及其以上的Unicode代码点。这两个代码单元被称为代理对。<br>3.代理对甩开了字符串元素计数，length，charAt、charCodeAt方法以及正则表达式（例如“.”）受到了影响。<br>4.使用第三方的库编写可识别代码点的字符串操作。<br>5.每当你使用一个含有字符串操作的库时，你都需要查询该库的文档，看他如何处理代码点的整个范围</p>
<p>#尽量少用全局对象</p>
<p>1.避免声明全局变量<br>2.尽量声明局部变量<br>3.避免对全局对象添加属性、<br>4.使用全局对象类做平台特性检测。</p>
<p>#始终声明局部的变量<br>1.始终使用var声明新的局部变量。<br>2.考虑使用lint工具帮助检查为绑定的变量。</p>
<p>#避免使用with<br>1.避免使用with语句<br>2.使用简短的变量名代替重复访问的对象。<br>3.显示地绑定局部变量到对象属性上，而不要使用with语句隐式地绑定他们。</p>
<p>#熟练掌握闭包</p>
<p>1.函数可以引用定义在其外部作用域的变量<br>2.闭包比创建它们的函数具有更长的生命周期<br>3.闭包在内部存储其外部变量的引用，并能读写这些变量</p>
<p>#理解变量提升</p>
<p>1.在代码块中的变量声明会被隐式地提升到函数的顶部。<br>2.重声明变量被视为单个变量<br>3.考虑手动提升局部变量的声明，从而避免混肴。</p>
<p>#使用立即调用的函数表达式创建局部作用域</p>
<p>1，理解绑定与复制的区别。<br>2.闭包通过引用而不是值捕获它们的外部变量。<br>3.使用立即调用的函数表达式来创建局部作用域。<br>4.当心在立即调用的函数表达式中包裹代码块可能改变其行为的情形。</p>
<p>#当心命名函数表达式笨拙的作用域</p>
<p>1.在error对象和调试器中使用命名函数表达式改进栈跟踪<br>2.在ES3和有问题的JavaScript环境中谨记函数表达式作用域会被Object.prototype污染<br>3.谨记在错误百出的JavaScript环境中会提升命名函数声明，并导致命名函数表达式的重复存储。<br>4.考虑避免使用命名函数表达式或在发布前删除函数名<br>5.如果你将代码发布到正确实现的ES5环境中，那么你没有什么好担心的。</p>
<p>#当心局部快函数声明笨拙的作用域</p>
<p>1.始终将函数声明之雨程序或被包含的函数的自耦外层以避免不可抑制的行为。<br>2.使用var声明和有田间的赋值语句代替有条件的函数声明。</p>
<p>#避免使用eval创建局部变量</p>
<p>1.避免使用eval函数创建的变量污染调用者的作用域。<br>2.如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染。</p>
<p>#间接调用eval函数优于直接调用<br>1.将eval函数同毫无意义的一个字面量包裹在序列表达式中以达到强制使用间接调用eval的目的<br>2.尽可能间接地调用eval函数，而不要直接调用eval函数。</p>
<p>#理解函数调用、方法调用及构造函数调用之间的不同<br>1.方法调用将被查找方法属性的对象作为调用接受者。<br>2.函数调用将全局对象（处于严格模式下则为undefined）作为其接收者。一般很少使用函数调用语法来调用方法。<br>3.构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者。</p>
<p>#熟练掌握高阶函数<br>1.高阶函数是那些将函数作为参数或返回值的函数<br>2.熟悉掌握现有库中的高阶函数<br>3.学会发现可以被高阶函数所取代的常见的编码模式</p>
<p>#使用call方法自定义接收者来调用方法<br>1.使用call方法自定义接收者来调用函数<br>2.使用call方法可以调用在给定的对象中不存在的方法<br>3.使用call方法定义高阶函数允许使用者给回调函数指定接收者</p>
<p>#使用apply方法通过不同数量的参数调用函数<br>1.使用apply方法指定一个可计算的参数数组来调用可变参数的函数。<br>2.使用apply方法的第一个参数给可变参数的方法提供一个接收者。</p>
<p>#使用arguments创建可变参数的函数<br>1.使用隐式的arguments对象实现可变参数的函数。<br>2考虑可变参数的函数提供他一个额外的固定元数的版本，从而使使用者无需借助apply方法。</p>
<p>#永远不要修改arguments对象<br>1.永远不要修改arguments对象<br>2.使用[].slice.call(arguments)将arguments对象复制到一个真正的数组中再进行修改。</p>
<p>#使用变量保存arguments的引用<br>1.当引用arguments时当心函数嵌套层级<br>2.绑定一个明确作用于到arguments变量，从而可以在嵌套的函数中引用它。</p>
<p>#使用bind方法提取具有确定接收者的方法<br>1.要注意，提取一个方法不会讲方法的接收者绑定到该方法的对象上。<br>2.当给高阶函数传递方法时，使用匿名函数在适当的接收者上调用该方法。<br>3.使用bind方法创建绑定到适当接收者的函数。</p>
<p>#使用bind方法实现柯里化（将函数与其参数的一个自己绑定的技术称为函数柯里化）<br>1.使用bind方法实现函数柯里化,即创建一个固定需求参数自己的委托函数。<br>2.传入null或者undefined作为接受者的参数来实现函数柯里化，从而忽略其接受者。</p>
<p>#使用闭包而不是字符串来封装代码<br>1.当将字符串传递给eval函数以执行他们的API时，绝不要在字符串中包含局部变量引用。<br>2.接收函数调用的API优于使用eval函数执行字符串的API。</p>
<p>#不要信赖函数对象的tostring方法<br>1.当调用函数的tostring方法时，并没有要求JavaScript殷勤能够精确地获取导函数的源代码.<br>2。由于在不同的引擎下调用tostring方法的结果可能不同，所以绝不要信赖函数源代码的详细细节。<br>3.toString方法的执行结果并不会暴露存储在闭包中的局部变量值。<br>4.通常情况下，应该避免使用函数对象的toString方法。</p>
<p>#避免使用非标准的栈检查属性<br>1.避免使用非标准的arguments.caller和arguments。callee属性，因为他们不具备良好的可移植性。<br>2.避免使用非标准的函数对象caller属性，因为在包含全部栈信息方面，它是不可靠的。</p>
<p>#理解prototype，getPrototypeOf 和<em>proto</em>之间的不同<br>1.C。prototype用于建立由new C（）创建的对象的原型。<br>2.Obj。getprototypeof（obj）是ES5中用来获取obj对象的原型对象的标准方法。<br>3.obj.<em>proto</em>是获取obj对象的原型对象的非标准方法。<br>4.C.prototype属性是new C（）创建的对象的原型。<br>5.object。getprototypeof（obj）是ES5中检索对象原型的标准函数。<br>6。obj.<em>proto</em>是检索对象原型的非标准方法。<br>7.类是有一个构造函数和一个关联的原型组成的一种设计模式。</p>
<p>#使用object.getPrototypeOf函数而不要使用<em>proto</em>属性<br>1.在支持<em>proto</em>属性的非ES5环境中实现Object.getPrototypeOf函数。</p>
<p>#始终不要修改<em>proto</em>属性<br>1.这会降低可移植性，不同哦平台有各自的实现方法。<br>2.性能问题，现代JS引擎已经深度优化了获取和设置对象属性的行为。修改对象的内部结构会使一些优化失效。<br>3.可预测性问题，修改对象的原型链就相对其进行大脑移植。<br>4.用Object.create函数给新对象设置自定义的原型。</p>
<p>#是构造函数与new无关<br>例子：<br>    function A(params) {<br>        if(!(this instanceof A)){<br>            return new A(params);//或者Object。create（A。prototype）<br>        }<br>        //logic<br>    }<br>1.通过使用new操作符或者object.create方法在构造函数定义中调用自身使得该构造函数与调用语法无关。<br>2.当一个函数期望使用new操作符调用时，清晰地文档化该函数。！！！</p>
<p>#在原型中存储方法<br>1.将方法存储在实例对象中将创建该函数的多个副本，因为每个实例对象都有一份副本。<br>2.将方法存储与原型中由于存储在实例对象中</p>
<p>#使用闭包存储私有数据<br>1.闭包变量是私有的，只能通过局部的引用获取。<br>2.将局部变量作为私有数据从而通过方法实现信息隐藏。</p>
<p>#只将实例状态存储在实例对象中<br>1.共享可变数据可能会出问题，因为原型是被其所有的实力共享的。<br>2.将可变的实例状态存储在实例对象中。</p>
<p>#认识到this变量的隐式绑定问题。<br>1.this变量的作用域总是由其最近的封闭函数所确定。<br>2.使用一个局部变量（通常命名为self、me、that）使得this绑定对于内部函数是可用的。</p>
<p>#在子类的构造函数中调用父类的构造函数<br>1.在子类构造函数中显式传入this作为显式的接收者调用父类构造函数。<br>2.使用object.create函数来构造子类的原型对象以避免调用父类的构造函数。</p>
<p>#不要重用父类的属性名<br>1.留意父类使用的所有属性名。<br>2.不要在子类中重用父类的属性名。</p>
<p>#避免继承标准类<br>1.继承标准类往往会由于一些特殊的内部属性（如[[class]]）而被破坏<br>2.使用属性委托优于继承标准类</p>
<p>#将原型是为实现细节<br>1.对象是接口，原型是实现<br>2.避免检查你无法控制的对象的原型结构。<br>3.避免检查实现在你无法控制的对象内部的属性。</p>
<p>#避免使用轻率的猴子补丁（在不是自己控制的原型中增加方法）<br>1.避免使用轻率的猴子补丁。<br>2.记录程序库所执行的所有猴子补丁。<br>3.考虑通过将修改置于一个导出函数中，使猴子补丁成为可选的。<br>4.使用猴子补丁为确实的标准API提供polyfills。</p>
<p>#使用object的直接实例构造轻量级的字典<br>1.使用对象字面量构建轻量级字典。<br>2.轻量级字典应该是Object.prototype的直接自雷，以使forin循环免受原型污染。</p>
<p>#使用null原型以防止原型污染<br>1.在ES5环境中，使用object。create（null）创建的自由原型的空对象是不太容易被污染的。<br>2.在一些比较老的环境中，考虑使用{——proto——：null}。<br>3.但要注意<em>proto</em>既不标准，也不是完全可移植的。并且可能会在未来的Javascript环境中去除。<br>4.绝对不要使用“<em>proto</em>”名作为字典中的key，因为一些环境将其作为特殊的属性对待。</p>
<p>#使用hasOwnProperty方法以避免原型污染<br>1.使用hasOwnProperty方法以避免原型污染。<br>2.使用词法作用域和call方法避免覆盖hasOwnProperty方法。<br>3.考虑在封装hasOwnProperty测试样板代码的类中实现字典操作。<br>4.使用字典类避免将“<em>proto</em>”作为key来使用。</p>
<p>#使用数组而不要使用字典来存储有序集合<br>1.使用forin循环来美剧对象属性应当与顺序无关。<br>2.如果聚集运算字典中的数据，确保聚集操作与顺序无关。<br>3.使用数组而不是字典来存储有序集合。</p>
<p>#绝不要在Object.prototype中增加可枚举的属性。<br>1.避免在Object。prototype中增加属性。<br>2.考虑编写一个函数代替Object。prototype方法。<br>3.如果你确实需要在Object.prototype中增加属性，请使用ES5中的Object.defineProperty方法将它们定义为不可枚举的属性。</p>
<p>#避免在枚举期间修改对象<br>1.当使用forin循环枚举一个对象的属性时，确保不要修改该对象。<br>2.当迭代一个对象时，如果该对象的内容会在循环期间被改变，应该使用while循环或经典的for循环来代替forin循环。<br>3.为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象。</p>
<p>#数组迭代要优先使用for（循环而不是forin循环）<br>1.迭代数组的索引属性应当总是使用for循环而不是forin循环。<br>2.考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度。</p>
<p>#迭代方法优于循环<br>1.使用迭代方法（如Array.prototype。forEach和Array.prototype.map）替换for循环使的代码更可读，并且避免了重复循环控制逻辑。<br>2.使用自定义的迭代函数来抽象未被标准库支持的常见循环模式。<br>3.在需要提前终止循环的情况下，让然推荐使用传统的循环。另外，some和every方法也可用于提前退出。</p>
<p>#再类数组对象上复用通用的数组方法<br>1.对于类数组对象，通过提取方法对象并使用其call方法来复用通用的Array方法。<br>2.任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法。</p>
<p>#数组字面量优于数组构造函数<br>1.如果数组构造函数的第一个参数是数字则数组的构造函数行为是不同的。<br>2.使用数组字面量代替数组构造函数。</p>
<p>#保持一致的约定<br>1.在变量命名和函数签名中使用一致的约定。<br>2.不要偏离用户在他们的开发平台中很可能遇到的约定、</p>
<p>#将undefined看做“没有值”<br>1。避免使用undefined表示任何非特定值。<br>2.使用描述性的字符串值或明明不二属性的对象，而不要使用undefined或null来代表特定应用标志。<br>3.提供参数默认值应当采用测试undefined的方式，而不是检查arguments、length。<br>4.在允许0，nan或空字符串为有效参数的地方，决不要通过真值测试来实现参数默认值。</p>
<p>#接收关键字参数的选项对象<br>1.使用选项对象使得API更具有可读性、更容易记忆。<br>2.所有通过选项对象提供的参数应当被视为可选的。<br>3.使用extend函数抽象出从选项对象中提取值的逻辑。</p>
<p>#避免不必要的状态<br>1.尽可能地使用无状态的API。<br>2.如果API是有状态的，表示做出每个操作与那些状态有关联。</p>
<p>#适用结构类型设计灵活的接口<br>1.适用结构类型（也成为鸭子类型）来设计灵活的对象接口。<br>2.结构接口更灵活、更轻量，所以应该避免使用继承。<br>3.针对单元测试，使用mock对象即接口的替代实现来提供可的复验行为。</p>
<p>#区分数组对象和类数组对象<br>1.绝不重载与其他类型有重叠的结构类型。<br>2.当重载一个结构类型与其他类型是，先测试其他类型。<br>3.当重载其他对象类型，接受真数组而不是类数组对象。<br>4.文档标准API是否接受真数组或者类数组值。<br>5.使用ES5提供的Array。isArray方法测试真数组。</p>
<p>#避免过度的强制转换<br>1.避免强制转换和重载的混用。<br>2.考虑防御性递减是非预期的输入。</p>
<p>#支持方法链<br>1.使用方法链来连接无状态的操作。<br>2.通过在无状态的方法中返回新对象来支持方法链。<br>3.通过再有状态的方法中返回this来支持方法链。</p>
<p>#不要阻塞I/O事件队列<br>1.异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序。<br>2。JavaScript并发地接收事件，但会使用一个事件队列按序的处理事件处理程序。<br>3.在应用程序事件队列中绝不要使用阻塞的I/O。</p>
<p>#在异步序列中使用嵌套或命名的回调函数。<br>1.使用嵌套或命名的毁掉函数按顺序地执行多个异步操作。<br>2.尝试在过多的嵌套的回调函数和尴尬的命名的费嵌套毁掉函数之间取得平衡。<br>3.避免将可被并行执行的操作顺序化。</p>
<p>#当心丢弃错误<br>1.通过编写共享的错误处理函数来避免复制和粘贴错误处理代码。<br>2.确保明确地处理所有的错误条件以避免丢弃错误。</p>
<p>#对异步循环使用递归<br>1.循环不能是异步的。<br>2.使用递归函数在时间循环的单独伦次中执行迭代。<br>3.在时间循环的单独轮次中执行地柜，并不会导致调用栈溢出。</p>
<p>#不要在计算时阻塞事件队列<br>1.避免在主事件队列中执行代价高昂的算法。<br>2.在支持workerAPI平台，该API可以用来在一个独立的事件队列中运行长计算程序。<br>3.在WorkerAPI不可用或代价高昂的环境中，考虑将计算程序分解到时间循环的多个轮次当中，</p>
<p>#实用技术起来执行并行操作<br>1.Javascript应用程序中事件方式是不确定的，及顺序是不可预测的。<br>2.使用计数器避免并行操作中的数据竞争。</p>
<p>#绝不要同步地调用异步的回调函数<br>1.即使可以立即得到数据，也绝不要同步地调用异步回调函数。<br>2.同步地调用异步的回调函数扰乱了预期的操作序列，并可能导致意想不到的交错代码。<br>3.同步第调用异步的回调函数可能导致栈溢出或错误地处理异常。<br>4.使用异步的API，比如setTimeOut函数来调度异步回调函数，时期运行于另一个回合。</p>
<p>#使用Promise模式清洁异步逻辑<br>1.promise代表最终值，即并行操作完成时最终产生的结果。<br>2.使用promise组合不同的并行操作。<br>3.使用promise模式的API避免数据竞争。<br>4.在要求有意的竞争条件是使用select（也被称为choose）；</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/04/13/设计模式读后感/">
  <time datetime="2016-04-13T15:04:38.000Z">
    2016-04-13
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/04/13/设计模式读后感/">设计模式读后感</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#“组合优于继承！！！”</p>
<p>##Facade（门面）模式：<br>意图：希望简化原有系统的使用方式。需要定义自己的借口。<br>问题：只需要使用某个复杂系统的子集，或者需要以一种特殊的方式与系统交互。<br>解决方案： facade为原有系统的客户提供了一个新的接口。<br>参与者与协作者：为客户提供的一个简化接口，使系统更容易使用。<br>效果：facade模式简化了对象所需子系统的使用过程。但是，由于facade并不完整，因此客户可能无法使用某些功能。<br>实现： 定义一个或多个具备所需接口的新类。<br>      让新的类使用原有的系统。<br>感悟：就是把原先的多个接口所返回的数据用一个新的类包装起来，在新类中可以对这些数据进行整合。使其能够被更方便的运用。</p>
<hr>
<p>##Adapter（适配者）模式：<br>意图：是控制范围外的一个原有对象与某个接口匹配。<br>问题：系统的数据和行为都正确，单接口不服。通常用于必须从抽象类派生时。<br>解决方案：Adapter模式提供了具有所需接口的包装类。<br>参与者与协作者：Adapter改变了Adaptee的接口，使Adaptee与Adapter的基础类型Target匹配。<br>这样用户就可以使用Adaptee了，好像它是Target类型。<br>效果：Adapter模式使原有对象能够适应新的类结构，不受其接口的限制。<br>实现：将原有的类包含在另一个类之中。让曝韩磊与需要的接口匹配，调用被包容类的方法。<br>感悟：就是原有的接口所返回的数据可能是有冗余或者格式不符合使用者的要求，这时候就需要建立一个中间层，来把这些数据进行适当的转换。</p>
<hr>
<p>##Strategy（策略）模式：<br>意图：可以根据所处上下文，使用不同的业务规则或算法。<br>问题：对所需算法的选择取决于发出请求的客户或者要处理的数据。如果只有一些不会变化的算法，就不需要strategy模式。<br>解决方案： 将对算法的选择和算法的实现相分离。允许根据上下文进行选择。<br>参与者与协作者： strategy制定了如何使用不同的算法。<br>                各个ConcreteStrategy实现了这些不同的算法。<br>                Context 通过类型为Strategy的引用使用具体的Concrete-strategy。strategy与context相互作用以实现所选的算法<br>                （有时候strategy必须查询context）。context将来自client的请求转发给strategy。<br>效果： strategy模式定义了一系列的算法。<br>      可以不使用switch语句或条件语句。<br>      必须以相同的方式调用所有的算法（他们必须拥有相同的接口）。各concretestrategy与context之间的相互作用可能需要在context中加入获取<br>      状态的方法。<br>实现： 让实用算法的类（context）包含一个抽象类（strategy），该抽象类有一个抽吸那个方法指定如何调用算法，每个派生类氨溴要实现算法。注意，在圆形strategy<br>模式中，选择所用具体实现的职责由client对象承担，并转给strategy模式的context对象。<br>感悟： 有点像后面所说的工厂模式，只不过工厂模式是用来创造所需对象，而策略模式则是返回对应的算法；工厂模式是创建型模式，策略模式是行为型模式。<br>其更关注行为的封装，追求的时返回的值。</p>
<hr>
<p>##Bridge模式：<br>意图：将一组实现与另一组使用它们的对象分离。<br>问题：一个抽象类的派生类必须使用多个实现，单不能出现类数量爆炸性增长。<br>解决方案： 为所有事先定义一个接口，供抽象类的所有派生类使用。<br>参与者与协作者: Abstraction 为要实现的对象定义接口，implementor为具体的实现类定义接口。abstraction的派生类使用Implement的<br>派生类，却无需知道自己具体使用哪一个concreteimplementor。<br>效果： 实现与使用实现的对象解耦，提供了可扩展性，客户对象无需操心实现问题。<br>实现：将实现封装在一个抽象类中。<br>     在要实现的抽象的基类中包含一个实现的句柄。注意：在Java中，你可以在实现中使用接口来代替抽象类。<br>感悟：把具体实现跟其抽象类分离，这样子就能使得具体实现在其他场合的时候能够轻易的使用其他的抽象类。</p>
<hr>
<p>##Abstract Factory模式<br>意图 需要为特定的客户（或情况 提供对象组。<br>问题 需要实例化一组相关的对象<br>解决方案 协调对象组的创建。提供一种方式，将如何执行对象实例化的规则从使用这些对象的客户对象提取出来。<br>参与者与协作者 AbstractFactory为如何创建对象组的每个成员定义接口。一般每个组都有独立的ConcreteFactory 进行创建。<br>效果 这个模式将 使用哪些对象 的规则与 如何使用这些对象 的逻辑分离开来。<br>实现 定义一个抽象类来制定创建那些对象。然后为每个组实现一个具体类。可以用表或文件完成同样的任务。</p>
<hr>
<p>##Decorator 模式<br>意图 动态地给一个对象添加职责<br>问题 要使用的对象将执行所需的基本功能。 但是，可能需要为这个对象将添加某些功能，这些附加功能可能发生在对象的基础功能之前或之后<br>。<br>解决方案 可以无需创建子类，而扩展一个对象的功能<br>参与者与协作者 concreteComonent让Decorator对形象为自己添加功能。有时候用ConcreteComonent的爱生类提供核心功能，在这种情况加ConcreteComonent累就不再是具体的，而是抽象的，comonentlei<br>comonent类定义了在所有这些类所使用的接口。<br>效果 所添加的功能放在小对象中。好处是可以在concretecomonent对象的功能之前或之后动态添加功能。单对象连总是终与concretecomonent对象。<br>实现 创建一个抽象类来表示原类喝药要添加到这个类的新功能。在装饰类中，将对新功能的调用放在对紧随其后对象的之后，以获得正确的顺序。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/18/div居中技巧/">
  <time datetime="2016-03-17T16:22:32.000Z">
    2016-03-18
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/18/div居中技巧/">元素居中技巧</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>首先先提供一个有趣的工具，这个工具能够很容易生成各种元素的居中代码。<br><a href="http://howtocenterincss.com/#contentType=text&amp;horizontal=center&amp;vertical=middle&amp;browser.IE=none" target="_blank" rel="external">http://howtocenterincss.com/#contentType=text&amp;horizontal=center&amp;vertical=middle&amp;browser.IE=none</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/17/HTML标签语义化概略/">
  <time datetime="2016-03-16T16:09:35.000Z">
    2016-03-17
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/17/HTML标签语义化概略/">HTML标签语义化概略</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>##详细介绍请看：<br>–<a href="http://www.ccjk.com/html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">http://www.ccjk.com/html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/</a></p>
<ol>
<li><code>&lt;article&gt;</code>  定义独立的内容，如论坛帖子、报纸文章、博客条目、用户评论等内容。</li>
<li><code>&lt;aside&gt;</code>定义两栏或多栏页面的侧边栏内容，如联系我们、客服、网站公告等内容。</li>
<li><code>&lt;audio&gt;</code>定义音频内容，如音乐或其他音频流。<br>autoplay    autoplay    自动播放。<br>controls    controls    显示控件。<br>loop    loop    自动重播。<br>preload preload 预备播放。如果使用 “autoplay”，则忽略该属性。<br>src url 音频的URL。<br>支持HTML5的全局属性和事件属性。<br>`<br>&lt;!– <audio src="”audio.wav”"><br>您的浏览器不支持 audio 标签。（注：可以在开始标签和结束标签之间加上此文本内容，这样若浏览器不支持此元素，就可以显示出这个信息。）</audio></li>
</ol>
<p> –&gt;`</p>
<ol>
<li><code>&lt;code&gt;&lt;!-- &lt;canvas&gt; --&gt;&lt;/code&gt;</code>定义图形，如图表和其他图像。（注：<canvas> 只是图形容器，我们必须使用脚本来绘制图形。）</canvas></li>
<li><code>&lt;code&gt;&lt;!-- &lt;command&gt; --&gt;&lt;/code&gt;</code>标记定义一个命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。</li>
<li><code>&lt;code&gt;&lt;!-- &lt;datalist&gt; --&gt;&lt;/code&gt;</code>定义选项列表，需与 input 元素配合使用，通过input 元素的 list 属性来绑定，用来定义 input 可能的值。datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。</li>
<li><code>&lt;code&gt;&lt;details&gt;&lt;/code&gt;</code>用于描述文档或文档某个部分的细节。</li>
<li><code>&lt;code&gt;&lt;embed&gt;&lt;/code&gt;</code>定义外部的可交互的内容或插件。</li>
<li><code>&lt;code&gt;&lt;figure&gt;&lt;/code&gt;</code>定义一组媒体内容（图像、图表、照片、代码等）以及它们的标题。如果被删除，则不应对文档流产生影响。</li>
<li><code>&lt;code&gt;&lt;footer&gt;&lt;/code&gt;</code>定义一个页面或一个区域的页脚。可包含文档的作者姓名、创作日期或者联系信息。</li>
<li><code>&lt;code&gt;&lt;header&gt;&lt;/code&gt;</code>定义一个页面或一个区域的头部。</li>
<li><code>&lt;code&gt;&lt;hgroup&gt;&lt;/code&gt;</code>定义文件中一个区块的相关信息，使用 <hgroup> 标签对网页或区段（section）的标题进行组合。</hgroup></li>
<li><code>&lt;code&gt;&lt;keygen&gt;&lt;/code&gt;</code>定义表单里一个生成的键值。规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。</li>
<li><code>&lt;code&gt;&lt;mark&gt;&lt;/code&gt;</code>定义有标记的文本。请在需要突出显示文本时使用此标签。</li>
<li><code>&lt;code&gt;&lt;meter&gt;&lt;/code&gt;</code>定义度量衡。仅用于已知最大和最小值的度量。（注：必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。）</li>
<li><code>&lt;code&gt;&lt;nav&gt;&lt;/code&gt;</code>定义导航链接。（注：如果文档中有“前后”按钮，则应该把它放到 <nav> 元素中。）</nav></li>
<li><code>&lt;code&gt;&lt;output&gt;&lt;/code&gt;</code>定义不同类型的输出，比如脚本的输出。</li>
<li><code>&lt;code&gt;&lt;progress&gt;&lt;/code&gt;</code>定义任务（如下载）的过程，可以使用此标签来显示 JavaScript 中耗费时间的函数的进度。</li>
<li><code>&lt;code&gt;&lt;section&gt;&lt;/code&gt;</code>定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</li>
<li><code>&lt;code&gt;&lt;source&gt;&lt;/code&gt;</code>为媒介元素（比如 <video> 和 <audio>）定义媒介资源。</audio></video></li>
<li><code>&lt;code&gt;&lt;time&gt;&lt;/code&gt;</code>定义一个日期/时间，该元素能够以机器可读的方式对日期和时间进行编码，举例说，用户代理能够把生日提醒或排定的事件添加到用户日程表中，搜索引擎也能够生成更智能的搜索结果。</li>
<li><code>&lt;code&gt;&lt;address&gt;&lt;/code&gt;</code> 表明作者的名字等详细信息</li>
<li><code>&lt;code&gt;&lt;legend&gt;&lt;/code&gt;</code>表单的标题</li>
<li><code>&lt;code&gt;&lt;fieldset&gt;&lt;/code&gt;</code>带标题的表单框要配合legend使用</li>
<li><code>&lt;code&gt;&lt;tbody&gt;&lt;tfoot&gt;&lt;/code&gt;</code>表格的时候使用，搭配th来表明表格的表头，身体，尾部</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/15/gulp的使用方法/">
  <time datetime="2016-03-15T15:40:24.000Z">
    2016-03-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/15/gulp的使用方法/">gulp的使用方法</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>基本用法<br>// gulpfile.js<br>gulp.task(‘foo’, function() {<br>    gulp.src(glob)<br>        .pipe(…)<br>        .pipe(…)<br>        .pipe(gulp.dest(…))<br>        .pipe(…)<br>        .pipe(gulp.dest(…))<br>});</p>
<p>// shell<br>$ gulp foo<br>基本 API<br>gulp.src(glob[, options])<br>根据 glob 匹配文件，返回 stream，可以通过 .pipe() 方法传递给后续的插件。<br>gulp.dest(path[, options])<br>一般用法 .pipe(gulp.dest(path))，把 pipe 中的内容按照指定的 path 写成文件，会自动创建不存在的文件夹。<br>注意，可以通过 .pipe 多次指定输出的地方，具体请看 这里<br>gulp.task(name[, deps], fn)<br>定义名为 name 的任务，定义之后就可以在命令行中使用 gulp xxx 来执行任务。<br>deps 里面的任务全部完成后才会执行 fn<br>deps 里面的任务都是并行执行的，如果需要顺序执行，需要特殊写法。具体看 这里<br>gulp.watch(glob[, opts, cb])<br>监听文件变化<br>不会监听新文件（目录），所以一般你会需要 gulp-watch<br>常用命令 （自定义）</p>
<h1 id="for-development-mode"><a href="#for-development-mode" class="headerlink" title="for development mode"></a>for development mode</h1><p>gulp server</p>
<h1 id="run-test"><a href="#run-test" class="headerlink" title="run test"></a>run test</h1><p>gulp test</p>
<h1 id="for-production-mode"><a href="#for-production-mode" class="headerlink" title="for production mode"></a>for production mode</h1><p>gulp build<br>gulp server 流程<br>把 less, sass, 之类的文件编译成 CSS，常用插件：<br>gulp-less<br>gulp-sass<br>创建 Web Server (with Live Reload)，常用：<br>gulp-connect，用来创建 Web Server，其实还有其他选择的，但多数都是利用 connect 来创建 Web Server 的。<br>node-proxy-middle，用来代理请求，可以把 /api/xxx 发送到指定的地址。(常用于 SPA 开发)<br>connect-modrewrite，匹配资源，如果不匹配就可以重定向到指定地址。(常用于 SPA 开发)<br>connect-history-api-fallback，作用同上，也用于匹配资源，但用起来简单很多。(常用于 SPA 开发)<br>监听文件变化，常用插件：<br>gulp-watch<br>示例代码<br>    gulp.task(‘clean:css’, function () {<br>        del.sync(‘app/styles/*.css’);<br>    });</p>
<pre><code>gulp.task(&apos;less&apos;, [&apos;clean:css&apos;], function () {
    var stream = gulp
            .src(&apos;app/styles/main.less&apos;)
            .pipe(less())
            .pipe(gulp.dest(&apos;app/styles/&apos;));
    return stream;
});

gulp.task(&apos;connect&apos;, function () {
    connect.server({
        root: &apos;./app&apos;,
        port: 9000,
        livereload: true,
        middleware: function (connect, o) {
            return [
                (function () {
                    var url = require(&apos;url&apos;);
                    var proxy = require(&apos;proxy-middleware&apos;);
                    var options = url.parse(&apos;http://localhost:3000/api&apos;);
                    options.route = &apos;/api&apos;;
                    return proxy(options);
                })(),
                modRewrite([
                    &apos;!\\.html|\\.js|\\.css|\\.swf|\\.jp(e?)g|\\.png|\\.gif|\\.eot|\\.woff|\\.ttf|\\.svg$ /index.html&apos;
                ])
            ];
        }
    });
});

gulp.task(&apos;watch&apos;, function () {
    gulp
        .src(&apos;app/styles/**/*.less&apos;, {read: false})
        .pipe(watch(&apos;app/styles/**/*.less&apos;, function () {
            return gulp
                .src(&apos;app/styles/main.less&apos;)
                .pipe(less())
                .pipe(gulp.dest(&apos;app/styles/&apos;))
                .pipe(connect.reload());
        }));

gulp
    .src([&apos;app/scripts/**/*.js&apos;, &apos;app/**/*.html&apos;])
    .pipe(watch([&apos;app/scripts/**/*.js&apos;, &apos;app/**/*.html&apos;]))
    .pipe(plumber())
    .pipe(connect.reload());
});

gulp.task(&apos;server&apos;, [&apos;less&apos;, &apos;connect&apos;, &apos;watch&apos;]);
gulp build 流程
清理 dist/ 文件夹
del，根据 glob 来删除文件/目录
压缩文件
gulp-htmlmin，压缩 html 文件
gulp-minify-html，同上
gulp-cssmin，压缩 css 文件
gulp-minify-css，同上，封装了 clean-css，star 比上面的多
gulp-uglify，混淆 JavaScript 代码
gulp-usemin，合并指定 block 中的文件
gulp-rev，给静态文件加上版本号，如 app.js -&gt; app-d41d8cd98f.js
复制其他文件到 dist/
gulp.src(...).pipe(gulp.dest(...))
实例代码
gulp.task(&apos;clean:build&apos;, function () {
    del.sync(&apos;dist/&apos;, {force: true});
});

gulp.task(&apos;minify&apos;, [&apos;clean:build&apos;, &apos;less&apos;], function () {
    gulp
        .src(&apos;app/views/**/*.html&apos;)
        .pipe(htmlmin({collapseWhitespace: true}))
        .pipe(gulp.dest(&apos;dist/views&apos;));

    gulp
        .src(&apos;app/index.html&apos;)
        .pipe(usemin({
            js: [uglify(), rev()],
            css: [minifyCss(), &apos;concat&apos;, rev()]
        }))
        .pipe(gulp.dest(&apos;dist/&apos;));
});

gulp.task(&apos;copyfonts&apos;, function () {
    gulp
        .src(&apos;app/styles/fonts/*&apos;)
        .pipe(gulp.dest(&apos;dist/fonts/&apos;));
});

gulp.task(&apos;build&apos;, [&apos;clean:build&apos;, &apos;minify&apos;, &apos;copyfonts&apos;]);
</code></pre><p>转载自 scarlex 的文章 利用gulp处理前端工作流程 </p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/14/创建六边形div/">
  <time datetime="2016-03-14T15:41:26.000Z">
    2016-03-14
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/14/创建六边形div/">创建六边形div</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#如何创建一个六边形的div<br>要创建一个六边形的div就要求使用到CSS3<br>中的旋转属性。六边形的div可以被分解为3个矩形重叠而成。<br><img src="../img/1.png" alt=""><br>通过图片可以发现，由于div之间的层叠遮挡关系，实际上能展示出来的区域<br>只有大概其中的1/2。<br><img src="../img/2.png" alt=""><br>所以在设置div的大笑的时候首先，要比预计的六边形要大2倍。第二长宽比要保证是在4:3否则便就对不齐了。<br>当前提都做好后，就要开始应用旋转了。通过计算得出，每两个矩形div之间要形成60度的夹角。</p>
<pre><code>
    transform: rotate(120deg);
</code></pre>
在使用css3时记住要进行兼容性检查，通过添加-webkit-等后缀避免页面出错。
继续话题，如果3个div是各自独立的话，那么可以想象出在最表面的那个div会不受限制，把其中的所有内容都展现出来，为了解决这个问题，就要将这些div嵌套起来。
<pre><code>
        <div class="box box-first ">
                        <div class="boxF">
                            <div class="boxS">
                                <div class="boxT ">
                                    <div class="border borderF "></div>
                                    <div class="border borderS "></div>
                                    <div class="border borderT "></div>
                                    <img src="" style="height: 100%;" class="blur background">
                                    <div class="overlay col-xs-3">
                                        <a href="#"></a>
                                    </div>

                                </div>
                            </div>
                        </div>
</div></code></pre>
通过嵌套的div+css设置为overflow：hidden，就能起到了父div在一个方向上限制子div的内容展现。从而达成最内部的div只能显示为一个6边形。
PS。为了帮div设置边框也是在耗费了一定的时间，由于是通过各div间互相制约制作的，所以要帮其添加边框就不能够采取直接在div上添加border属性，只能够在其内部另外在设置3个只有短边有border的div来形成边框效果。
css：<pre><code>
       .clear {
                clear: both;
            }

            .background {
                display: inline-block;
            }

            .box {
                float: left;
                z-index: 6;
                display: none;
            }

            .lineF,
            .lineS {
                position: absolute;
                visibility: visible;
                z-index: 5;
            }

            .box-first,
            .box-second {
                margin-left: -webkit-calc(50% - 300px);
                margin-left: -moz-calc(50% - 300px);
                margin-left: calc(50% - 300px);
            }

            .boxMore {
                margin-left: -webkit-calc(50% - 200px);
                margin-left: -moz-calc(50% - 200px);
                margin-left: calc(50% - 200px);
            }

            .lineS {
                top: 172px;
                left: 116px;
            }

            .boxF,
            .boxS,
            .boxT,
            .overlay {
                width: 200px;
                height: 250px;
                overflow: hidden;
            }

            .boxF,
            .boxS {
                visibility: hidden;
            }

            .boxF {
                transform: rotate(120deg);
                float: left;
                margin-left: 0px;
                -ms-transform: rotate(120deg);
                -moz-transform: rotate(120deg);
                -webkit-transform: rotate(120deg);
            }

            .boxS {
                transform: rotate(-60deg);
                -ms-transform: rotate(-60deg);
                -moz-transform: rotate(-60deg);
                -webkit-transform: rotate(-60deg);
            }

            .boxT {
                transform: rotate(-60deg);
                background: no-repeat 50% center;
                background-size: cover;
                -ms-transform: rotate(-60deg);
                -moz-transform: rotate(-60deg);
                -webkit-transform: rotate(-60deg);
                visibility: visible;
            }

            .overlay {
                transition: all 250ms ease-in-out 0s;
                display: inline-block;
                position: absolute;
                z-index: 7;
                text-align: center;
                top: 0px;
            }

            .overlay a {
                display: none;
                border-radius: 3px;
                line-height: 32px;
                text-decoration: none;
                color: White;
                font-size: 18px;
                font-weight: bolder;
                margin-top: 110px;
            }

            .overlay:hover a {
                color: white;
                display: inline-block;
            }

            .border {
                border-top: 0px;
                border-bottom: 0px;
                border-left: 3px solid white;
                border-right: 3px solid white;
                position: absolute;
                z-index: 6;
                width: 200px;
                height: 115px;
                top: 27%;
            }

            .borderS {
                transform: rotate(60deg);
                -ms-transform: rotate(60deg);
                -moz-transform: rotate(60deg);
                -webkit-transform: rotate(60deg);
            }

            .borderT {
                transform: rotate(120deg);
                -ms-transform: rotate(120deg);
                -moz-transform: rotate(120deg);
                -webkit-transform: rotate(120deg);
            }
</code></pre>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/11/22/js中的call和apply的作用/">
  <time datetime="2015-11-22T11:39:57.000Z">
    2015-11-22
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/11/22/js中的call和apply的作用/">js中的call和apply的作用 </a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>这两个方法都是每个函数都自带的方法，用途都是在特定的时候调用函数，同时修改this的指向，<br>避免传入参数的不正确。同时还能够对一个原本不含有某个方法的函数，调用这个方法。<br>例子：<br>    function Animal(){<br>    this.name = “Animal”;<br>    this.showName = function(){<br>        alert(this.name);<br>    }<br>    }    </p>
<pre><code>function Cat(){    
    this.name = &quot;Cat&quot;;    
}    

var animal = new Animal();    
var cat = new Cat();    

//输入结果为&quot;Cat&quot;    
animal.showName.call(cat,&quot;,&quot;);    
//animal.showName.apply(cat,[]);  
</code></pre><p>在这里，通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。<br>而且还能实现继承。<br>例子：<br>      function Animal(name){<br>        this.name = name;<br>        this.showName = function(){<br>            alert(this.name);<br>        }<br>    }      </p>
<pre><code>function Cat(name){    
    Animal.call(this, name);    
}      

var cat = new Cat(&quot;Black Cat&quot;);     
cat.showName();
</code></pre><p> Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么 Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了.<br>区别：apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。<br>call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
    <a href="/page/2/" class="next">下一页</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">kyjo2014</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>