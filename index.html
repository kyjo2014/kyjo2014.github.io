<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>LTH&#39;s note book</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="kyjo2014">
  
  
  <meta name="description" content="html|css|javascript|LTH&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LTH's note book">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LTH's note book">
<meta property="og:description" content="html|css|javascript|LTH&apos;s blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LTH's note book">
<meta name="twitter:description" content="html|css|javascript|LTH&apos;s blog">
  
    <link rel="alternate" href="/atom.xml" title="LTH&#39;s note book" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">LTH&#39;s note book</a></h1>
    <p><a href="/">逗逼+未来の程序员</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/Reading">Reading</a></li>
      
        <li><a href="/about">About</a></li>
      
        <li><a href="/testing">TestArea</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/07/19/effective-JS/">
  <time datetime="2016-07-19T01:45:58.000Z">
    2016-07-19
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/07/19/effective-JS/">effective JS</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#了解你使用的JS版本<br>1.确定你的应用程序支持JS的哪些版本。<br>2.确保你使用的任何Js的特性对于应用程序将要运行的所有环境都是支持的。<br>3.总是在执行严格模式检查的环境中测试严格代码。<br>4.当心链接那些在不同严格模式下有不同预期的脚本。</p>
<p>#理解JS的浮点数<br>1.JS的数字都是双精度浮点数。<br>2.js中的证书仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型。<br>3.位运算符将数字视为32位的有符号整数。<br>4.当心浮点运算中的精度陷阱。</p>
<p>#当心隐式的强制类型转换<br>1.类型错误可能被隐式的强制转换所隐藏<br>2.重载的运算符+是进行加法运算还是字符串连接操作取决于其参数类型。<br>3.对象通过valueof方法强制转换为数字，通过toString方法强制转换为字符串。<br>4.对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串。<br>5.具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示。<br>6.测试一个值是否为未定义的值,应该使用typeof或者与undefined进行比较而不是使用真值运算。</p>
<p>#原始类型由于封装对象<br>1.当做相等比较时，原始类型的封装对象预期原是指行为不一样。<br>2.获取和设置原始类型值的属性会隐式地创建封装对象。</p>
<p>#避免对混合类型使用==运算符<br>1.当参数类型不同时， ==运算符应用了一套难以理解的隐式强制转换就能明白的比较运算。<br>2.使用===运算符，使读者不需要涉及任何的隐式强制转换就能明白你的比较运算符。<br>3.当比较不同类型的值时，使用你自己的现实强制转换是程序的行为更清晰。</p>
<p>#了解分号插入的局限</p>
<p>1.仅在“}”标记之前、一行的结束和程序的结束处推导分号。<br>2.仅在紧接着的标记不能被解析的时候推导分号。</p>
<ol>
<li>在以（、[、+、-或/字符开头的语句前绝不能省略分号。</li>
<li>当脚本链接的时候，在脚本之间显示地插入分号。<br>5.在return、throw、break\continue、或–的参数之前绝不能换行。<br>6.分号不能作为for循环的头部或空语句的分隔符而被推导出。</li>
</ol>
<p>#视字符串为16位的代码单元序列</p>
<p>1.JS字符串由16的代码单元组成，而不是由Unicode代码点组成。<br>2.js使用两个代码单元表示2^16，及其以上的Unicode代码点。这两个代码单元被称为代理对。<br>3.代理对甩开了字符串元素计数，length，charAt、charCodeAt方法以及正则表达式（例如“.”）受到了影响。<br>4.使用第三方的库编写可识别代码点的字符串操作。<br>5.每当你使用一个含有字符串操作的库时，你都需要查询该库的文档，看他如何处理代码点的整个范围</p>
<p>#尽量少用全局对象</p>
<p>1.避免声明全局变量<br>2.尽量声明局部变量<br>3.避免对全局对象添加属性、<br>4.使用全局对象类做平台特性检测。</p>
<p>#始终声明局部的变量<br>1.始终使用var声明新的局部变量。<br>2.考虑使用lint工具帮助检查为绑定的变量。</p>
<p>#避免使用with<br>1.避免使用with语句<br>2.使用简短的变量名代替重复访问的对象。<br>3.显示地绑定局部变量到对象属性上，而不要使用with语句隐式地绑定他们。</p>
<p>#熟练掌握闭包</p>
<p>1.函数可以引用定义在其外部作用域的变量<br>2.闭包比创建它们的函数具有更长的生命周期<br>3.闭包在内部存储其外部变量的引用，并能读写这些变量</p>
<p>#理解变量提升</p>
<p>1.在代码块中的变量声明会被隐式地提升到函数的顶部。<br>2.重声明变量被视为单个变量<br>3.考虑手动提升局部变量的声明，从而避免混肴。</p>
<p>#使用立即调用的函数表达式创建局部作用域</p>
<p>1，理解绑定与复制的区别。<br>2.闭包通过引用而不是值捕获它们的外部变量。<br>3.使用立即调用的函数表达式来创建局部作用域。<br>4.当心在立即调用的函数表达式中包裹代码块可能改变其行为的情形。</p>
<p>#当心命名函数表达式笨拙的作用域</p>
<p>1.在error对象和调试器中使用命名函数表达式改进栈跟踪<br>2.在ES3和有问题的JavaScript环境中谨记函数表达式作用域会被Object.prototype污染<br>3.谨记在错误百出的JavaScript环境中会提升命名函数声明，并导致命名函数表达式的重复存储。<br>4.考虑避免使用命名函数表达式或在发布前删除函数名<br>5.如果你将代码发布到正确实现的ES5环境中，那么你没有什么好担心的。</p>
<p>#当心局部快函数声明笨拙的作用域</p>
<p>1.始终将函数声明之雨程序或被包含的函数的自耦外层以避免不可抑制的行为。<br>2.使用var声明和有田间的赋值语句代替有条件的函数声明。</p>
<p>#避免使用eval创建局部变量</p>
<p>1.避免使用eval函数创建的变量污染调用者的作用域。<br>2.如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染。</p>
<p>#间接调用eval函数优于直接调用<br>1.将eval函数同毫无意义的一个字面量包裹在序列表达式中以达到强制使用间接调用eval的目的<br>2.尽可能间接地调用eval函数，而不要直接调用eval函数。</p>
<p>#理解函数调用、方法调用及构造函数调用之间的不同<br>1.方法调用将被查找方法属性的对象作为调用接受者。<br>2.函数调用将全局对象（处于严格模式下则为undefined）作为其接收者。一般很少使用函数调用语法来调用方法。<br>3.构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者。</p>
<p>#熟练掌握高阶函数<br>1.高阶函数是那些将函数作为参数或返回值的函数<br>2.熟悉掌握现有库中的高阶函数<br>3.学会发现可以被高阶函数所取代的常见的编码模式</p>
<p>#使用call方法自定义接收者来调用方法<br>1.使用call方法自定义接收者来调用函数<br>2.使用call方法可以调用在给定的对象中不存在的方法<br>3.使用call方法定义高阶函数允许使用者给回调函数指定接收者</p>
<p>#使用apply方法通过不同数量的参数调用函数<br>1.使用apply方法指定一个可计算的参数数组来调用可变参数的函数。<br>2.使用apply方法的第一个参数给可变参数的方法提供一个接收者。</p>
<p>#使用arguments创建可变参数的函数<br>1.使用隐式的arguments对象实现可变参数的函数。<br>2考虑可变参数的函数提供他一个额外的固定元数的版本，从而使使用者无需借助apply方法。</p>
<p>#永远不要修改arguments对象<br>1.永远不要修改arguments对象<br>2.使用[].slice.call(arguments)将arguments对象复制到一个真正的数组中再进行修改。</p>
<p>#使用变量保存arguments的引用<br>1.当引用arguments时当心函数嵌套层级<br>2.绑定一个明确作用于到arguments变量，从而可以在嵌套的函数中引用它。</p>
<p>#使用bind方法提取具有确定接收者的方法<br>1.要注意，提取一个方法不会讲方法的接收者绑定到该方法的对象上。<br>2.当给高阶函数传递方法时，使用匿名函数在适当的接收者上调用该方法。<br>3.使用bind方法创建绑定到适当接收者的函数。</p>
<p>#使用bind方法实现柯里化（将函数与其参数的一个自己绑定的技术称为函数柯里化）<br>1.使用bind方法实现函数柯里化,即创建一个固定需求参数自己的委托函数。<br>2.传入null或者undefined作为接受者的参数来实现函数柯里化，从而忽略其接受者。</p>
<p>#使用闭包而不是字符串来封装代码<br>1.当将字符串传递给eval函数以执行他们的API时，绝不要在字符串中包含局部变量引用。<br>2.接收函数调用的API优于使用eval函数执行字符串的API。</p>
<p>#不要信赖函数对象的tostring方法<br>1.当调用函数的tostring方法时，并没有要求JavaScript殷勤能够精确地获取导函数的源代码.<br>2。由于在不同的引擎下调用tostring方法的结果可能不同，所以绝不要信赖函数源代码的详细细节。<br>3.toString方法的执行结果并不会暴露存储在闭包中的局部变量值。<br>4.通常情况下，应该避免使用函数对象的toString方法。</p>
<p>#避免使用非标准的栈检查属性<br>1.避免使用非标准的arguments.caller和arguments。callee属性，因为他们不具备良好的可移植性。<br>2.避免使用非标准的函数对象caller属性，因为在包含全部栈信息方面，它是不可靠的。</p>
<p>#理解prototype，getPrototypeOf 和<em>proto</em>之间的不同<br>1.C。prototype用于建立由new C（）创建的对象的原型。<br>2.Obj。getprototypeof（obj）是ES5中用来获取obj对象的原型对象的标准方法。<br>3.obj.<em>proto</em>是获取obj对象的原型对象的非标准方法。<br>4.C.prototype属性是new C（）创建的对象的原型。<br>5.object。getprototypeof（obj）是ES5中检索对象原型的标准函数。<br>6。obj.<em>proto</em>是检索对象原型的非标准方法。<br>7.类是有一个构造函数和一个关联的原型组成的一种设计模式。</p>
<p>#使用object.getPrototypeOf函数而不要使用<em>proto</em>属性<br>1.在支持<em>proto</em>属性的非ES5环境中实现Object.getPrototypeOf函数。</p>
<p>#始终不要修改<em>proto</em>属性<br>1.这会降低可移植性，不同哦平台有各自的实现方法。<br>2.性能问题，现代JS引擎已经深度优化了获取和设置对象属性的行为。修改对象的内部结构会使一些优化失效。<br>3.可预测性问题，修改对象的原型链就相对其进行大脑移植。<br>4.用Object.create函数给新对象设置自定义的原型。</p>
<p>#是构造函数与new无关<br>例子：<br>    function A(params) {<br>        if(!(this instanceof A)){<br>            return new A(params);//或者Object。create（A。prototype）<br>        }<br>        //logic<br>    }<br>1.通过使用new操作符或者object.create方法在构造函数定义中调用自身使得该构造函数与调用语法无关。<br>2.当一个函数期望使用new操作符调用时，清晰地文档化该函数。！！！</p>
<p>#在原型中存储方法<br>1.将方法存储在实例对象中将创建该函数的多个副本，因为每个实例对象都有一份副本。<br>2.将方法存储与原型中由于存储在实例对象中</p>
<p>#使用闭包存储私有数据<br>1.闭包变量是私有的，只能通过局部的引用获取。<br>2.将局部变量作为私有数据从而通过方法实现信息隐藏。</p>
<p>#只将实例状态存储在实例对象中<br>1.共享可变数据可能会出问题，因为原型是被其所有的实力共享的。<br>2.将可变的实例状态存储在实例对象中。</p>
<p>#认识到this变量的隐式绑定问题。<br>1.this变量的作用域总是由其最近的封闭函数所确定。<br>2.使用一个局部变量（通常命名为self、me、that）使得this绑定对于内部函数是可用的。</p>
<p>#在子类的构造函数中调用父类的构造函数<br>1.在子类构造函数中显式传入this作为显式的接收者调用父类构造函数。<br>2.使用object.create函数来构造子类的原型对象以避免调用父类的构造函数。</p>
<p>#不要重用父类的属性名<br>1.留意父类使用的所有属性名。<br>2.不要在子类中重用父类的属性名。</p>
<p>#避免继承标准类<br>1.继承标准类往往会由于一些特殊的内部属性（如[[class]]）而被破坏<br>2.使用属性委托优于继承标准类</p>
<p>#将原型是为实现细节<br>1.对象是接口，原型是实现<br>2.避免检查你无法控制的对象的原型结构。<br>3.避免检查实现在你无法控制的对象内部的属性。</p>
<p>#避免使用轻率的猴子补丁（在不是自己控制的原型中增加方法）<br>1.避免使用轻率的猴子补丁。<br>2.记录程序库所执行的所有猴子补丁。<br>3.考虑通过将修改置于一个导出函数中，使猴子补丁成为可选的。<br>4.使用猴子补丁为确实的标准API提供polyfills。</p>
<p>#使用object的直接实例构造轻量级的字典<br>1.使用对象字面量构建轻量级字典。<br>2.轻量级字典应该是Object.prototype的直接自雷，以使forin循环免受原型污染。</p>
<p>#使用null原型以防止原型污染<br>1.在ES5环境中，使用object。create（null）创建的自由原型的空对象是不太容易被污染的。<br>2.在一些比较老的环境中，考虑使用{——proto——：null}。<br>3.但要注意<em>proto</em>既不标准，也不是完全可移植的。并且可能会在未来的Javascript环境中去除。<br>4.绝对不要使用“<em>proto</em>”名作为字典中的key，因为一些环境将其作为特殊的属性对待。</p>
<p>#使用hasOwnProperty方法以避免原型污染<br>1.使用hasOwnProperty方法以避免原型污染。<br>2.使用词法作用域和call方法避免覆盖hasOwnProperty方法。<br>3.考虑在封装hasOwnProperty测试样板代码的类中实现字典操作。<br>4.使用字典类避免将“<em>proto</em>”作为key来使用。</p>
<p>#使用数组而不要使用字典来存储有序集合<br>1.使用forin循环来美剧对象属性应当与顺序无关。<br>2.如果聚集运算字典中的数据，确保聚集操作与顺序无关。<br>3.使用数组而不是字典来存储有序集合。</p>
<p>#绝不要在Object.prototype中增加可枚举的属性。<br>1.避免在Object。prototype中增加属性。<br>2.考虑编写一个函数代替Object。prototype方法。<br>3.如果你确实需要在Object.prototype中增加属性，请使用ES5中的Object.defineProperty方法将它们定义为不可枚举的属性。</p>
<p>#避免在枚举期间修改对象<br>1.当使用forin循环枚举一个对象的属性时，确保不要修改该对象。<br>2.当迭代一个对象时，如果该对象的内容会在循环期间被改变，应该使用while循环或经典的for循环来代替forin循环。<br>3.为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象。</p>
<p>#数组迭代要优先使用for（循环而不是forin循环）<br>1.迭代数组的索引属性应当总是使用for循环而不是forin循环。<br>2.考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度。</p>
<p>#迭代方法优于循环<br>1.使用迭代方法（如Array.prototype。forEach和Array.prototype.map）替换for循环使的代码更可读，并且避免了重复循环控制逻辑。<br>2.使用自定义的迭代函数来抽象未被标准库支持的常见循环模式。<br>3.在需要提前终止循环的情况下，让然推荐使用传统的循环。另外，some和every方法也可用于提前退出。</p>
<p>#再类数组对象上复用通用的数组方法<br>1.对于类数组对象，通过提取方法对象并使用其call方法来复用通用的Array方法。<br>2.任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法。</p>
<p>#数组字面量优于数组构造函数<br>1.如果数组构造函数的第一个参数是数字则数组的构造函数行为是不同的。<br>2.使用数组字面量代替数组构造函数。</p>
<p>#保持一致的约定<br>1.在变量命名和函数签名中使用一致的约定。<br>2.不要偏离用户在他们的开发平台中很可能遇到的约定、</p>
<p>#将undefined看做“没有值”<br>1。避免使用undefined表示任何非特定值。<br>2.使用描述性的字符串值或明明不二属性的对象，而不要使用undefined或null来代表特定应用标志。<br>3.提供参数默认值应当采用测试undefined的方式，而不是检查arguments、length。<br>4.在允许0，nan或空字符串为有效参数的地方，决不要通过真值测试来实现参数默认值。</p>
<p>#接收关键字参数的选项对象<br>1.使用选项对象使得API更具有可读性、更容易记忆。<br>2.所有通过选项对象提供的参数应当被视为可选的。<br>3.使用extend函数抽象出从选项对象中提取值的逻辑。</p>
<p>#避免不必要的状态<br>1.尽可能地使用无状态的API。<br>2.如果API是有状态的，表示做出每个操作与那些状态有关联。</p>
<p>#适用结构类型设计灵活的接口<br>1.适用结构类型（也成为鸭子类型）来设计灵活的对象接口。<br>2.结构接口更灵活、更轻量，所以应该避免使用继承。<br>3.针对单元测试，使用mock对象即接口的替代实现来提供可的复验行为。</p>
<p>#区分数组对象和类数组对象<br>1.绝不重载与其他类型有重叠的结构类型。<br>2.当重载一个结构类型与其他类型是，先测试其他类型。<br>3.当重载其他对象类型，接受真数组而不是类数组对象。<br>4.文档标准API是否接受真数组或者类数组值。<br>5.使用ES5提供的Array。isArray方法测试真数组。</p>
<p>#避免过度的强制转换<br>1.避免强制转换和重载的混用。<br>2.考虑防御性递减是非预期的输入。</p>
<p>#支持方法链<br>1.使用方法链来连接无状态的操作。<br>2.通过在无状态的方法中返回新对象来支持方法链。<br>3.通过再有状态的方法中返回this来支持方法链。</p>
<p>#不要阻塞I/O事件队列<br>1.异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序。<br>2。JavaScript并发地接收事件，但会使用一个事件队列按序的处理事件处理程序。<br>3.在应用程序事件队列中绝不要使用阻塞的I/O。</p>
<p>#在异步序列中使用嵌套或命名的回调函数。<br>1.使用嵌套或命名的毁掉函数按顺序地执行多个异步操作。<br>2.尝试在过多的嵌套的回调函数和尴尬的命名的费嵌套毁掉函数之间取得平衡。<br>3.避免将可被并行执行的操作顺序化。</p>
<p>#当心丢弃错误<br>1.通过编写共享的错误处理函数来避免复制和粘贴错误处理代码。<br>2.确保明确地处理所有的错误条件以避免丢弃错误。</p>
<p>#对异步循环使用递归<br>1.循环不能是异步的。<br>2.使用递归函数在时间循环的单独伦次中执行迭代。<br>3.在时间循环的单独轮次中执行地柜，并不会导致调用栈溢出。</p>
<p>#不要在计算时阻塞事件队列<br>1.避免在主事件队列中执行代价高昂的算法。<br>2.在支持workerAPI平台，该API可以用来在一个独立的事件队列中运行长计算程序。<br>3.在WorkerAPI不可用或代价高昂的环境中，考虑将计算程序分解到时间循环的多个轮次当中，</p>
<p>#实用技术起来执行并行操作<br>1.Javascript应用程序中事件方式是不确定的，及顺序是不可预测的。<br>2.使用计数器避免并行操作中的数据竞争。</p>
<p>#绝不要同步地调用异步的回调函数<br>1.即使可以立即得到数据，也绝不要同步地调用异步回调函数。<br>2.同步地调用异步的回调函数扰乱了预期的操作序列，并可能导致意想不到的交错代码。<br>3.同步第调用异步的回调函数可能导致栈溢出或错误地处理异常。<br>4.使用异步的API，比如setTimeOut函数来调度异步回调函数，时期运行于另一个回合。</p>
<p>#使用Promise模式清洁异步逻辑<br>1.promise代表最终值，即并行操作完成时最终产生的结果。<br>2.使用promise组合不同的并行操作。<br>3.使用promise模式的API避免数据竞争。<br>4.在要求有意的竞争条件是使用select（也被称为choose）；</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/04/13/设计模式读后感/">
  <time datetime="2016-04-13T15:04:38.000Z">
    2016-04-13
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/04/13/设计模式读后感/">设计模式读后感</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#“组合优于继承！！！”</p>
<p>##Facade（门面）模式：<br>意图：希望简化原有系统的使用方式。需要定义自己的借口。<br>问题：只需要使用某个复杂系统的子集，或者需要以一种特殊的方式与系统交互。<br>解决方案： facade为原有系统的客户提供了一个新的接口。<br>参与者与协作者：为客户提供的一个简化接口，使系统更容易使用。<br>效果：facade模式简化了对象所需子系统的使用过程。但是，由于facade并不完整，因此客户可能无法使用某些功能。<br>实现： 定义一个或多个具备所需接口的新类。<br>      让新的类使用原有的系统。<br>感悟：就是把原先的多个接口所返回的数据用一个新的类包装起来，在新类中可以对这些数据进行整合。使其能够被更方便的运用。</p>
<hr>
<p>##Adapter（适配者）模式：<br>意图：是控制范围外的一个原有对象与某个接口匹配。<br>问题：系统的数据和行为都正确，单接口不服。通常用于必须从抽象类派生时。<br>解决方案：Adapter模式提供了具有所需接口的包装类。<br>参与者与协作者：Adapter改变了Adaptee的接口，使Adaptee与Adapter的基础类型Target匹配。<br>这样用户就可以使用Adaptee了，好像它是Target类型。<br>效果：Adapter模式使原有对象能够适应新的类结构，不受其接口的限制。<br>实现：将原有的类包含在另一个类之中。让曝韩磊与需要的接口匹配，调用被包容类的方法。<br>感悟：就是原有的接口所返回的数据可能是有冗余或者格式不符合使用者的要求，这时候就需要建立一个中间层，来把这些数据进行适当的转换。</p>
<hr>
<p>##Strategy（策略）模式：<br>意图：可以根据所处上下文，使用不同的业务规则或算法。<br>问题：对所需算法的选择取决于发出请求的客户或者要处理的数据。如果只有一些不会变化的算法，就不需要strategy模式。<br>解决方案： 将对算法的选择和算法的实现相分离。允许根据上下文进行选择。<br>参与者与协作者： strategy制定了如何使用不同的算法。<br>                各个ConcreteStrategy实现了这些不同的算法。<br>                Context 通过类型为Strategy的引用使用具体的Concrete-strategy。strategy与context相互作用以实现所选的算法<br>                （有时候strategy必须查询context）。context将来自client的请求转发给strategy。<br>效果： strategy模式定义了一系列的算法。<br>      可以不使用switch语句或条件语句。<br>      必须以相同的方式调用所有的算法（他们必须拥有相同的接口）。各concretestrategy与context之间的相互作用可能需要在context中加入获取<br>      状态的方法。<br>实现： 让实用算法的类（context）包含一个抽象类（strategy），该抽象类有一个抽吸那个方法指定如何调用算法，每个派生类氨溴要实现算法。注意，在圆形strategy<br>模式中，选择所用具体实现的职责由client对象承担，并转给strategy模式的context对象。<br>感悟： 有点像后面所说的工厂模式，只不过工厂模式是用来创造所需对象，而策略模式则是返回对应的算法；工厂模式是创建型模式，策略模式是行为型模式。<br>其更关注行为的封装，追求的时返回的值。</p>
<hr>
<p>##Bridge模式：<br>意图：将一组实现与另一组使用它们的对象分离。<br>问题：一个抽象类的派生类必须使用多个实现，单不能出现类数量爆炸性增长。<br>解决方案： 为所有事先定义一个接口，供抽象类的所有派生类使用。<br>参与者与协作者: Abstraction 为要实现的对象定义接口，implementor为具体的实现类定义接口。abstraction的派生类使用Implement的<br>派生类，却无需知道自己具体使用哪一个concreteimplementor。<br>效果： 实现与使用实现的对象解耦，提供了可扩展性，客户对象无需操心实现问题。<br>实现：将实现封装在一个抽象类中。<br>     在要实现的抽象的基类中包含一个实现的句柄。注意：在Java中，你可以在实现中使用接口来代替抽象类。<br>感悟：把具体实现跟其抽象类分离，这样子就能使得具体实现在其他场合的时候能够轻易的使用其他的抽象类。</p>
<hr>
<p>##Abstract Factory模式<br>意图 需要为特定的客户（或情况 提供对象组。<br>问题 需要实例化一组相关的对象<br>解决方案 协调对象组的创建。提供一种方式，将如何执行对象实例化的规则从使用这些对象的客户对象提取出来。<br>参与者与协作者 AbstractFactory为如何创建对象组的每个成员定义接口。一般每个组都有独立的ConcreteFactory 进行创建。<br>效果 这个模式将 使用哪些对象 的规则与 如何使用这些对象 的逻辑分离开来。<br>实现 定义一个抽象类来制定创建那些对象。然后为每个组实现一个具体类。可以用表或文件完成同样的任务。</p>
<hr>
<p>##Decorator 模式<br>意图 动态地给一个对象添加职责<br>问题 要使用的对象将执行所需的基本功能。 但是，可能需要为这个对象将添加某些功能，这些附加功能可能发生在对象的基础功能之前或之后<br>。<br>解决方案 可以无需创建子类，而扩展一个对象的功能<br>参与者与协作者 concreteComonent让Decorator对形象为自己添加功能。有时候用ConcreteComonent的爱生类提供核心功能，在这种情况加ConcreteComonent累就不再是具体的，而是抽象的，comonentlei<br>comonent类定义了在所有这些类所使用的接口。<br>效果 所添加的功能放在小对象中。好处是可以在concretecomonent对象的功能之前或之后动态添加功能。单对象连总是终与concretecomonent对象。<br>实现 创建一个抽象类来表示原类喝药要添加到这个类的新功能。在装饰类中，将对新功能的调用放在对紧随其后对象的之后，以获得正确的顺序。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/18/div居中技巧/">
  <time datetime="2016-03-17T16:22:32.000Z">
    2016-03-18
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/18/div居中技巧/">元素居中技巧</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>首先先提供一个有趣的工具，这个工具能够很容易生成各种元素的居中代码。<br><a href="http://howtocenterincss.com/#contentType=text&amp;horizontal=center&amp;vertical=middle&amp;browser.IE=none" target="_blank" rel="external">http://howtocenterincss.com/#contentType=text&amp;horizontal=center&amp;vertical=middle&amp;browser.IE=none</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/17/HTML标签语义化概略/">
  <time datetime="2016-03-16T16:09:35.000Z">
    2016-03-17
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/17/HTML标签语义化概略/">HTML标签语义化概略</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>##详细介绍请看：<br>–<a href="http://www.ccjk.com/html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">http://www.ccjk.com/html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/</a></p>
<ol>
<li><code>&lt;article&gt;</code>  定义独立的内容，如论坛帖子、报纸文章、博客条目、用户评论等内容。</li>
<li><code>&lt;aside&gt;</code>定义两栏或多栏页面的侧边栏内容，如联系我们、客服、网站公告等内容。</li>
<li><code>&lt;audio&gt;</code>定义音频内容，如音乐或其他音频流。<br>autoplay    autoplay    自动播放。<br>controls    controls    显示控件。<br>loop    loop    自动重播。<br>preload preload 预备播放。如果使用 “autoplay”，则忽略该属性。<br>src url 音频的URL。<br>支持HTML5的全局属性和事件属性。<br>`<br>&lt;!– <audio src="”audio.wav”"><br>您的浏览器不支持 audio 标签。（注：可以在开始标签和结束标签之间加上此文本内容，这样若浏览器不支持此元素，就可以显示出这个信息。）</audio></li>
</ol>
<p> –&gt;`</p>
<ol>
<li><code>&lt;code&gt;&lt;!-- &lt;canvas&gt; --&gt;&lt;/code&gt;</code>定义图形，如图表和其他图像。（注：<canvas> 只是图形容器，我们必须使用脚本来绘制图形。）</canvas></li>
<li><code>&lt;code&gt;&lt;!-- &lt;command&gt; --&gt;&lt;/code&gt;</code>标记定义一个命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。</li>
<li><code>&lt;code&gt;&lt;!-- &lt;datalist&gt; --&gt;&lt;/code&gt;</code>定义选项列表，需与 input 元素配合使用，通过input 元素的 list 属性来绑定，用来定义 input 可能的值。datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。</li>
<li><code>&lt;code&gt;&lt;details&gt;&lt;/code&gt;</code>用于描述文档或文档某个部分的细节。</li>
<li><code>&lt;code&gt;&lt;embed&gt;&lt;/code&gt;</code>定义外部的可交互的内容或插件。</li>
<li><code>&lt;code&gt;&lt;figure&gt;&lt;/code&gt;</code>定义一组媒体内容（图像、图表、照片、代码等）以及它们的标题。如果被删除，则不应对文档流产生影响。</li>
<li><code>&lt;code&gt;&lt;footer&gt;&lt;/code&gt;</code>定义一个页面或一个区域的页脚。可包含文档的作者姓名、创作日期或者联系信息。</li>
<li><code>&lt;code&gt;&lt;header&gt;&lt;/code&gt;</code>定义一个页面或一个区域的头部。</li>
<li><code>&lt;code&gt;&lt;hgroup&gt;&lt;/code&gt;</code>定义文件中一个区块的相关信息，使用 <hgroup> 标签对网页或区段（section）的标题进行组合。</hgroup></li>
<li><code>&lt;code&gt;&lt;keygen&gt;&lt;/code&gt;</code>定义表单里一个生成的键值。规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。</li>
<li><code>&lt;code&gt;&lt;mark&gt;&lt;/code&gt;</code>定义有标记的文本。请在需要突出显示文本时使用此标签。</li>
<li><code>&lt;code&gt;&lt;meter&gt;&lt;/code&gt;</code>定义度量衡。仅用于已知最大和最小值的度量。（注：必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。）</li>
<li><code>&lt;code&gt;&lt;nav&gt;&lt;/code&gt;</code>定义导航链接。（注：如果文档中有“前后”按钮，则应该把它放到 <nav> 元素中。）</nav></li>
<li><code>&lt;code&gt;&lt;output&gt;&lt;/code&gt;</code>定义不同类型的输出，比如脚本的输出。</li>
<li><code>&lt;code&gt;&lt;progress&gt;&lt;/code&gt;</code>定义任务（如下载）的过程，可以使用此标签来显示 JavaScript 中耗费时间的函数的进度。</li>
<li><code>&lt;code&gt;&lt;section&gt;&lt;/code&gt;</code>定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</li>
<li><code>&lt;code&gt;&lt;source&gt;&lt;/code&gt;</code>为媒介元素（比如 <video> 和 <audio>）定义媒介资源。</audio></video></li>
<li><code>&lt;code&gt;&lt;time&gt;&lt;/code&gt;</code>定义一个日期/时间，该元素能够以机器可读的方式对日期和时间进行编码，举例说，用户代理能够把生日提醒或排定的事件添加到用户日程表中，搜索引擎也能够生成更智能的搜索结果。</li>
<li><code>&lt;code&gt;&lt;address&gt;&lt;/code&gt;</code> 表明作者的名字等详细信息</li>
<li><code>&lt;code&gt;&lt;legend&gt;&lt;/code&gt;</code>表单的标题</li>
<li><code>&lt;code&gt;&lt;fieldset&gt;&lt;/code&gt;</code>带标题的表单框要配合legend使用</li>
<li><code>&lt;code&gt;&lt;tbody&gt;&lt;tfoot&gt;&lt;/code&gt;</code>表格的时候使用，搭配th来表明表格的表头，身体，尾部</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/15/gulp的使用方法/">
  <time datetime="2016-03-15T15:40:24.000Z">
    2016-03-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/15/gulp的使用方法/">gulp的使用方法</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>基本用法<br>// gulpfile.js<br>gulp.task(‘foo’, function() {<br>    gulp.src(glob)<br>        .pipe(…)<br>        .pipe(…)<br>        .pipe(gulp.dest(…))<br>        .pipe(…)<br>        .pipe(gulp.dest(…))<br>});</p>
<p>// shell<br>$ gulp foo<br>基本 API<br>gulp.src(glob[, options])<br>根据 glob 匹配文件，返回 stream，可以通过 .pipe() 方法传递给后续的插件。<br>gulp.dest(path[, options])<br>一般用法 .pipe(gulp.dest(path))，把 pipe 中的内容按照指定的 path 写成文件，会自动创建不存在的文件夹。<br>注意，可以通过 .pipe 多次指定输出的地方，具体请看 这里<br>gulp.task(name[, deps], fn)<br>定义名为 name 的任务，定义之后就可以在命令行中使用 gulp xxx 来执行任务。<br>deps 里面的任务全部完成后才会执行 fn<br>deps 里面的任务都是并行执行的，如果需要顺序执行，需要特殊写法。具体看 这里<br>gulp.watch(glob[, opts, cb])<br>监听文件变化<br>不会监听新文件（目录），所以一般你会需要 gulp-watch<br>常用命令 （自定义）</p>
<h1 id="for_development_mode">for development mode</h1><p>gulp server</p>
<h1 id="run_test">run test</h1><p>gulp test</p>
<h1 id="for_production_mode">for production mode</h1><p>gulp build<br>gulp server 流程<br>把 less, sass, 之类的文件编译成 CSS，常用插件：<br>gulp-less<br>gulp-sass<br>创建 Web Server (with Live Reload)，常用：<br>gulp-connect，用来创建 Web Server，其实还有其他选择的，但多数都是利用 connect 来创建 Web Server 的。<br>node-proxy-middle，用来代理请求，可以把 /api/xxx 发送到指定的地址。(常用于 SPA 开发)<br>connect-modrewrite，匹配资源，如果不匹配就可以重定向到指定地址。(常用于 SPA 开发)<br>connect-history-api-fallback，作用同上，也用于匹配资源，但用起来简单很多。(常用于 SPA 开发)<br>监听文件变化，常用插件：<br>gulp-watch<br>示例代码<br>    gulp.task(‘clean:css’, function () {<br>        del.sync(‘app/styles/*.css’);<br>    });</p>
<pre><code>gulp.task(<span class="string">'less'</span>, [<span class="string">'clean:css'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">var</span> stream = gulp
            .src(<span class="string">'app/styles/main.less'</span>)
            .pipe(less())
            .pipe(gulp.dest(<span class="string">'app/styles/'</span>));
    <span class="keyword">return</span> stream;
});

gulp.task(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    connect.server({
        root: <span class="string">'./app'</span>,
        port: <span class="number">9000</span>,
        livereload: <span class="literal">true</span>,
        middleware: <span class="function"><span class="keyword">function</span> (<span class="params">connect, o</span>) </span>{
            <span class="keyword">return</span> [
                (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
                    <span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);
                    <span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'proxy-middleware'</span>);
                    <span class="keyword">var</span> options = url.parse(<span class="string">'http://localhost:3000/api'</span>);
                    options.route = <span class="string">'/api'</span>;
                    <span class="keyword">return</span> proxy(options);
                })(),
                modRewrite([
                    <span class="string">'!\\.html|\\.js|\\.css|\\.swf|\\.jp(e?)g|\\.png|\\.gif|\\.eot|\\.woff|\\.ttf|\\.svg$ /index.html'</span>
                ])
            ];
        }
    });
});

gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    gulp
        .src(<span class="string">'app/styles/**/*.less'</span>, {read: <span class="literal">false</span>})
        .pipe(watch(<span class="string">'app/styles/**/*.less'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
            <span class="keyword">return</span> gulp
                .src(<span class="string">'app/styles/main.less'</span>)
                .pipe(less())
                .pipe(gulp.dest(<span class="string">'app/styles/'</span>))
                .pipe(connect.reload());
        }));

gulp
    .src([<span class="string">'app/scripts/**/*.js'</span>, <span class="string">'app/**/*.html'</span>])
    .pipe(watch([<span class="string">'app/scripts/**/*.js'</span>, <span class="string">'app/**/*.html'</span>]))
    .pipe(plumber())
    .pipe(connect.reload());
});

gulp.task(<span class="string">'server'</span>, [<span class="string">'less'</span>, <span class="string">'connect'</span>, <span class="string">'watch'</span>]);
gulp build 流程
清理 dist/ 文件夹
del，根据 glob 来删除文件/目录
压缩文件
gulp-htmlmin，压缩 html 文件
gulp-minify-html，同上
gulp-cssmin，压缩 css 文件
gulp-minify-css，同上，封装了 clean-css，star 比上面的多
gulp-uglify，混淆 JavaScript 代码
gulp-usemin，合并指定 block 中的文件
gulp-rev，给静态文件加上版本号，如 app.js -&gt; app-d41d8cd98f.js
复制其他文件到 dist/
gulp.src(...).pipe(gulp.dest(...))
实例代码
gulp.task(<span class="string">'clean:build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    del.sync(<span class="string">'dist/'</span>, {force: <span class="literal">true</span>});
});

gulp.task(<span class="string">'minify'</span>, [<span class="string">'clean:build'</span>, <span class="string">'less'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    gulp
        .src(<span class="string">'app/views/**/*.html'</span>)
        .pipe(htmlmin({collapseWhitespace: <span class="literal">true</span>}))
        .pipe(gulp.dest(<span class="string">'dist/views'</span>));

    gulp
        .src(<span class="string">'app/index.html'</span>)
        .pipe(usemin({
            js: [uglify(), rev()],
            css: [minifyCss(), <span class="string">'concat'</span>, rev()]
        }))
        .pipe(gulp.dest(<span class="string">'dist/'</span>));
});

gulp.task(<span class="string">'copyfonts'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    gulp
        .src(<span class="string">'app/styles/fonts/*'</span>)
        .pipe(gulp.dest(<span class="string">'dist/fonts/'</span>));
});

gulp.task(<span class="string">'build'</span>, [<span class="string">'clean:build'</span>, <span class="string">'minify'</span>, <span class="string">'copyfonts'</span>]);
</code></pre><p>转载自 scarlex 的文章 利用gulp处理前端工作流程 </p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/03/14/创建六边形div/">
  <time datetime="2016-03-14T15:41:26.000Z">
    2016-03-14
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/03/14/创建六边形div/">创建六边形div</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>#如何创建一个六边形的div<br>要创建一个六边形的div就要求使用到CSS3<br>中的旋转属性。六边形的div可以被分解为3个矩形重叠而成。<br><img src="../img/1.png" alt=""><br>通过图片可以发现，由于div之间的层叠遮挡关系，实际上能展示出来的区域<br>只有大概其中的1/2。<br><img src="../img/2.png" alt=""><br>所以在设置div的大笑的时候首先，要比预计的六边形要大2倍。第二长宽比要保证是在4:3否则便就对不齐了。<br>当前提都做好后，就要开始应用旋转了。通过计算得出，每两个矩形div之间要形成60度的夹角。</p>
<pre><code>
    transform: rotate(120deg);
</code></pre>
在使用css3时记住要进行兼容性检查，通过添加-webkit-等后缀避免页面出错。
继续话题，如果3个div是各自独立的话，那么可以想象出在最表面的那个div会不受限制，把其中的所有内容都展现出来，为了解决这个问题，就要将这些div嵌套起来。
<pre><code>
        <div class="box box-first ">
                        <div class="boxF">
                            <div class="boxS">
                                <div class="boxT ">
                                    <div class="border borderF "></div>
                                    <div class="border borderS "></div>
                                    <div class="border borderT "></div>
                                    <img src="" style="height: 100%;" class="blur background">
                                    <div class="overlay col-xs-3">
                                        <a href="#"></a>
                                    </div>

                                </div>
                            </div>
                        </div>
</div></code></pre>
通过嵌套的div+css设置为overflow：hidden，就能起到了父div在一个方向上限制子div的内容展现。从而达成最内部的div只能显示为一个6边形。
PS。为了帮div设置边框也是在耗费了一定的时间，由于是通过各div间互相制约制作的，所以要帮其添加边框就不能够采取直接在div上添加border属性，只能够在其内部另外在设置3个只有短边有border的div来形成边框效果。
css：<pre><code>
       .clear {
                clear: both;
            }

            .background {
                display: inline-block;
            }

            .box {
                float: left;
                z-index: 6;
                display: none;
            }

            .lineF,
            .lineS {
                position: absolute;
                visibility: visible;
                z-index: 5;
            }

            .box-first,
            .box-second {
                margin-left: -webkit-calc(50% - 300px);
                margin-left: -moz-calc(50% - 300px);
                margin-left: calc(50% - 300px);
            }

            .boxMore {
                margin-left: -webkit-calc(50% - 200px);
                margin-left: -moz-calc(50% - 200px);
                margin-left: calc(50% - 200px);
            }

            .lineS {
                top: 172px;
                left: 116px;
            }

            .boxF,
            .boxS,
            .boxT,
            .overlay {
                width: 200px;
                height: 250px;
                overflow: hidden;
            }

            .boxF,
            .boxS {
                visibility: hidden;
            }

            .boxF {
                transform: rotate(120deg);
                float: left;
                margin-left: 0px;
                -ms-transform: rotate(120deg);
                -moz-transform: rotate(120deg);
                -webkit-transform: rotate(120deg);
            }

            .boxS {
                transform: rotate(-60deg);
                -ms-transform: rotate(-60deg);
                -moz-transform: rotate(-60deg);
                -webkit-transform: rotate(-60deg);
            }

            .boxT {
                transform: rotate(-60deg);
                background: no-repeat 50% center;
                background-size: cover;
                -ms-transform: rotate(-60deg);
                -moz-transform: rotate(-60deg);
                -webkit-transform: rotate(-60deg);
                visibility: visible;
            }

            .overlay {
                transition: all 250ms ease-in-out 0s;
                display: inline-block;
                position: absolute;
                z-index: 7;
                text-align: center;
                top: 0px;
            }

            .overlay a {
                display: none;
                border-radius: 3px;
                line-height: 32px;
                text-decoration: none;
                color: White;
                font-size: 18px;
                font-weight: bolder;
                margin-top: 110px;
            }

            .overlay:hover a {
                color: white;
                display: inline-block;
            }

            .border {
                border-top: 0px;
                border-bottom: 0px;
                border-left: 3px solid white;
                border-right: 3px solid white;
                position: absolute;
                z-index: 6;
                width: 200px;
                height: 115px;
                top: 27%;
            }

            .borderS {
                transform: rotate(60deg);
                -ms-transform: rotate(60deg);
                -moz-transform: rotate(60deg);
                -webkit-transform: rotate(60deg);
            }

            .borderT {
                transform: rotate(120deg);
                -ms-transform: rotate(120deg);
                -moz-transform: rotate(120deg);
                -webkit-transform: rotate(120deg);
            }
</code></pre>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/11/22/js中的call和apply的作用/">
  <time datetime="2015-11-22T11:39:57.000Z">
    2015-11-22
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/11/22/js中的call和apply的作用/">js中的call和apply的作用 </a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>这两个方法都是每个函数都自带的方法，用途都是在特定的时候调用函数，同时修改this的指向，<br>避免传入参数的不正确。同时还能够对一个原本不含有某个方法的函数，调用这个方法。<br>例子：<br>    function Animal(){<br>    this.name = “Animal”;<br>    this.showName = function(){<br>        alert(this.name);<br>    }<br>    }    </p>
<pre><code>function Cat(){    
    this.name = <span class="string">"Cat"</span>;    
}    

var <span class="keyword">animal</span> = new <span class="keyword">Animal</span>();    
var cat = new Cat();    

//输入结果为<span class="string">"Cat"</span>    
<span class="keyword">animal</span>.showName.call(cat,<span class="string">","</span>);    
//<span class="keyword">animal</span>.showName.apply(cat,<span class="comment">[]</span>);  
</code></pre><p>在这里，通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。<br>而且还能实现继承。<br>例子：<br>      function Animal(name){<br>        this.name = name;<br>        this.showName = function(){<br>            alert(this.name);<br>        }<br>    }      </p>
<pre><code>function Cat(name){    
    <span class="keyword">Animal</span>.call(this, name);    
}      

var cat = new Cat(<span class="string">"Black Cat"</span>);     
cat.showName();
</code></pre><p> Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么 Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了.<br>区别：apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。<br>call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/10/22/css-hack效果/">
  <time datetime="2015-10-22T14:51:59.000Z">
    2015-10-22
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/10/22/css-hack效果/">css hack效果</a></h1>
  

  </header>
  
  <div class="entry">
    
      <ul>
<li><a href="https://css-tricks.com/examples/ShapesOfCSS/" target="_blank" rel="external">https://css-tricks.com/examples/ShapesOfCSS/</a></li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/09/24/《H5核心技术》梗概/">
  <time datetime="2015-09-24T08:39:41.000Z">
    2015-09-24
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/09/24/《H5核心技术》梗概/">《H5核心技术》梗概</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>##canvas画布<br>画布的大小不要用css调整，一定要在标签中定义，否则会导致缩放问题。</p>
<hr>
<p>##由canvas创建一幅可另存为到本地的图片<br>利用<code>toDataURL()</code>接口，向网页中加入一个不可见的图像元素，有id值但是没有src属性。用css调整图像的位置与大小，让其覆盖在canvas上，提供<br>截图按钮。要截图的时候，用该接口向img的src提供值，同时img变可见，隐藏canvas。</p>
<hr>
<p>##创建离屏canvas<br>优势，把背景存放在<code>display:none</code>的canvas中提高动画的运行效率。</p>
<hr>
<p>##渐变色与图案<br><code>createLinearGradient()</code>(线性)和<code>createRadialGradient()</code>(放射性)中的addcolorstop即可设置颜色停止点在渐变线上的位置。</p>
<hr>
<p>##路径的闭合<br>要用beginpath()或者clearRect()来清除路径，否则rect()，lineTO()新开的路径会自动连接到上一次创建的路径的末端。用closePath则可以吧<br>有缺口的路径自动进行闭合。arc()方法默认以逆时针来进行绘制路径，arcTo()可以画一段圆角，以所给的两个点以及画的圆角的半径来作为参数。而在进行fill()的时候<br>路径会自动闭合而且会以逆时针的方式顺着线，然后在左边进行填充。</p>
<hr>
<p>##剪辑区域制作动画<br>利用clip()来调整需要剪辑的区域，然后使用clearRect()来清除掉内容。注意：调用clip()的时候记住要用save()和restore()来包裹住<br>他，否则由于clip()具有把剪辑区域设置为当前剪辑区域与当前路径的交集，那么剪辑区域会变得越来越小，而这是无法改变的。</p>
<hr>
<p>##文本编辑<br>文本编辑的时候光标的位置不要用measureText()来确定位置，因为这样只是测量了文本的宽度，而事实上用fillText()来渲染的时候可能会超出<br>文本的宽度。而在需要精确文本坐标的时候（要实现橡皮擦，删除文字的时候），最好是把该区域用clip()直接把整个区域的内容都擦除。</p>
<hr>
<p>##图像绘制的安全问题<br>canvas会通过设置origin-clean的标志位，如果用过drawImage()的话这个标志位就会变成false，在再次调用<code>toDataURL()</code>的时候就会出错。<br>而且为了防止网页中的恶意代码会篡改本地的文件系统，浏览器会把用户的文件系统与运行程序环境进行隔离，而在开发的时候可以通过设置在命令行中<br>以“–allow-file-access-from-files”参数来启动chrome浏览器让其绕开绘图安全机制。</p>
<hr>
<p>##性能对比</p>
<p>###使用getImageData()和drawImageData()时<br>1.不要频繁的使用getImageData()来获取少量数据，这样会使网页加载缓慢。<br>2.避免在循环体内直接访问对象的属性而应该将其存在局部变量中。<br>3.应该是用循环计数器来遍历完整的像素，而不是像素分量（红绿蓝，Alpha）。<br>4.不必使用逆向遍历和移位技巧。</p>
<hr>
<p>##绘制动画<br>通过使用“polyfill”方法（即另外写一个实现动画函数其中要包括（requestAnimationFrame||window.webkitRequestAnimationFrame||<br>window.mozRequestAnimationFrame||window.MsRequestAnimationFrame||一个使用settimeout的函数））来实现动画，这样才能避免由于浏览器兼容性问题。<br>浏览器会自动使用双缓冲区模式来绘制动画，所以不要重复手动创建一个所有内容都重新绘制的缓冲区。但是，在一些小部件上使用多重缓冲区依然能够使效率得到提升。</p>
<hr>
<p>##碰撞检测<br>外界矩形判别法，即两个凸多边形的话从每条边上作发现为投影轴，检测每个多边形在投影轴上的投影是否有分离，如有分离则未碰撞。<br>外界圆判别法，直接计算圆心距。<br>最小平移法：直接求定点到边的最小距离。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/09/20/浏览器类型检测方法/">
  <time datetime="2015-09-20T12:43:18.000Z">
    2015-09-20
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/09/20/浏览器类型检测方法/">浏览器类型检测方法</a></h1>
  

  </header>
  
  <div class="entry">
    
      
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
    <a href="/page/2/" class="next">下一页</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2016 <a href="/">kyjo2014</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>