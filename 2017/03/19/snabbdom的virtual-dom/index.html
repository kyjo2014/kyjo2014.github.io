<!DOCTYPE html>
<html lang="zh">
    <head>
    <!-- 
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.3.0 -->

    <!-- Title -->
    
    <title>
        
            snabbdom的virtual dom | 
        
        LTH&#39;s note book
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Meta & Info -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="kyjo2014">
    <meta name="description" content="html|css|javascript|LTH&#39;s blog">
    <meta name="keywords" content="123,virtualdom,vue源码">

    <!--iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="LTH&#39;s note book">

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://kyjo2014.github.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="snabbdom的virtual dom | LTH&#39;s note book">
    <meta property="og:description" content="html|css|javascript|LTH&#39;s blog">
    <meta property="og:article:tag" content="virtualdom"> <meta property="og:article:tag" content="vue源码"> 

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS -->
    <link rel="stylesheet" href="/css/material.min.css">
    <link rel="stylesheet" href="/css/style.min.css">
    <!-- Config CSS -->


<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }
</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>



    <script src="/js/jquery.min.js"></script>
    <script src="/js/queue.js"></script>

    <!-- UC Browser Compatible -->
    <script>
        var agent = navigator.userAgent.toLowerCase();
        if(agent.indexOf('ucbrowser')>0) {
            document.write("<link rel=\"stylesheet\" href=\"/css/uc.css\">");
            alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
        }
    </script>

    

    

    <!-- Bing Background -->
    

    <!-- Custom Head -->
    
</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->

    <!-- Left aligned menu below button -->
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#学习virtualdom-一"><span class="post-toc-number">1.</span> <span class="post-toc-text">学习virtualdom 一</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#vnode的定义"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">vnode的定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如何构造一个vnode"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">如何构造一个vnode</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#判断基本类型"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">判断基本类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对DOMAPI进行包装"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">对DOMAPI进行包装</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#snabbdom主文件"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">snabbdom主文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义的接口和变量"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">定义的接口和变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#init函数"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">init函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#module参数"><span class="post-toc-number">1.5.2.1.</span> <span class="post-toc-text">module参数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#api参数"><span class="post-toc-number">1.5.2.2.</span> <span class="post-toc-text">api参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vdom-diff算法"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">vdom diff算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#init返回的patch函数"><span class="post-toc-number">1.5.3.1.</span> <span class="post-toc-text">init返回的patch函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vdom-lifecycle-hook"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">vdom lifecycle hook</span></a></li></ol></li></ol></li></ol>

        <!--
        <li class="mdl-menu__item">
            Some Action
        </li>
        -->
    </ul>




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script>
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').css('background-image', 'url(' + '/img/random/material-' + randomNum + '.png' + ')');
</script>

        
    
            <p class="article-headline-p">
                snabbdom的virtual dom
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/myavatar.jpg" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>kyjo2014</strong>
        <span>3月 19, 2017</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/virtualdom/">virtualdom</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/vue源码/">vue源码</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=snabbdom的virtual dom&url=http://kyjo2014.github.com//2017/03/19/snabbdom的virtual-dom/index.html&pic=&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=snabbdom的virtual dom&url=http://kyjo2014.github.com//2017/03/19/snabbdom的virtual-dom/index.html&via=kyjo2014" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://kyjo2014.github.com//2017/03/19/snabbdom的virtual-dom/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://kyjo2014.github.com//2017/03/19/snabbdom的virtual-dom/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="学习virtualdom-一"><a href="#学习virtualdom-一" class="headerlink" title="学习virtualdom 一"></a>学习virtualdom 一</h1><ol>
<li>什么是vdom</li>
</ol>
<p>Virtual DOM 是一个模拟 DOM 树的 JavaScript 对象。框架使用 Virtual DOM 来渲染 UI，当组件状态  state有更改的时候，框架会自动调用组件的 render 方法重新渲染整个组件的 UI。<br>框架主要的目标是提供一套不同的, 高效的方案来更新DOM.不是通过直接把 DOM 变成可变的数据, 而是通过构建 “Virtual DOM”, 虚拟的 DOM, 随后 框架 处理真实的 DOM 上的更新来进行模拟相应的更新。</p>
<ol>
<li>为什么要使用vdom</li>
</ol>
<p>为什么相比于直接操控浏览器的Dom树，操控vdom会更快呢？毕竟最后vdom树也需要对真实的dom树进行操作。这里就要归功于vdom高效的diff和patch算法。如果直接在实际dom树上进行操作，那么每一次进行元素的操作都相当于对整棵dom树进行一次DFS（先序遍历），非常耗费时间（可以使用NodeIterator和TreeWalker自己实现getElementById）。而且如果一次更新大量的dom元素（不使用fragment）会使得浏览器进行大量的重绘操作。使用vdom的话就可以使得把对原先节点的增删查改操作都放在内存中进行，并且由于vdom的操作并不会马上就产生真实的效果，触发浏览器的重绘，这样就使得框架可以先计算出几乎最小的diff，然后再等到事件循环的结尾才对真实dom树进行批量的更新。因此，vdom的性能比原生dom快很多。</p>
<ol>
<li>如何实现vdom<br>vue2.0相比vue1.x版本增加了对vdom特性的支持。而vue2.0的vdom特性是源自于对snabbdom的魔改，接下来就看看snabbdom是怎么实现virtualdom的。</li>
</ol>
<blockquote>
<p><em>转载自<a href="http://www.jianshu.com/p/b461657e49c0" target="_blank" rel="external">袁韩的博客</a></em><br>virtual dom优化开发的方式是：通过vnode,来实现无状态组件,结合单向数据流(undirectional data flow),进行UI更新,整体代码结构是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var newVnode = render(vnode, state)</div><div class="line">var oldVnode = patch(oldVnode, newVnode)</div><div class="line">state.dispatch(&apos;change&apos;)</div><div class="line">var newVnode = render(vnode, state)</div><div class="line">var oldVnode = patch(oldVnode, newVnode)</div></pre></td></tr></table></figure></p>
</blockquote>
<p>我看的是<a href="https://github.com/snabbdom/snabbdom/tree/43908d81c804f91dba44e7007f3aff2bcd52efb2" target="_blank" rel="external">snabbdom</a>这个版本的代码。代码仓库中,</p>
<table>
<thead>
<tr>
<th>名字</th>
<th style="text-align:center">种类</th>
<th style="text-align:right">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>module</td>
<td style="text-align:center">目录</td>
<td style="text-align:right">存放对不同指令的解释模块</td>
</tr>
<tr>
<td>vnode</td>
<td style="text-align:center">文件</td>
<td style="text-align:right">vnode的构造函数</td>
</tr>
<tr>
<td>h</td>
<td style="text-align:center">文件</td>
<td style="text-align:right">负责把用户输入转化为vnode节点</td>
</tr>
<tr>
<td>is</td>
<td style="text-align:center">文件</td>
<td style="text-align:right">用于提供工具函数，验证值的类型</td>
</tr>
<tr>
<td>htmldomapi</td>
<td style="text-align:center">文件</td>
<td style="text-align:right">对domapi用函数进行包装，方便更好使用</td>
</tr>
<tr>
<td>snabbdom</td>
<td style="text-align:center">文件</td>
<td style="text-align:right">框架主体包含diff，patch，初始化函数</td>
</tr>
</tbody>
</table>
<p>这里先看一下snabbdom对vnode的定义：</p>
<h2 id="vnode的定义"><a href="#vnode的定义" class="headerlink" title="vnode的定义"></a>vnode的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">module.exports = function(sel, data, children, text, elm) &#123;</div><div class="line">  /*sel: vnode对应的选择器属性如标签名，id，class等，形式如‘div.btn.rm-btn’</div><div class="line">   *data： vnode所绑定的数据，可以有以下类型：attribute、props、eventlistner、class、dataset、hook</div><div class="line">   *children： 子vnode数组</div><div class="line">   *text：vnode节点内部的文本内容</div><div class="line">   *elm： 用来保存对实际dom节点的引用</div><div class="line">   *key： 用来区分不同vnode节点的唯一值</div><div class="line">   */</div><div class="line">  var key = data === undefined ? undefined : data.key;</div><div class="line">  return &#123;sel: sel, data: data, children: children,</div><div class="line">          text: text, elm: elm, key: key&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="如何构造一个vnode"><a href="#如何构造一个vnode" class="headerlink" title="如何构造一个vnode"></a>如何构造一个vnode</h2><p>接下来就要看一下怎么去构造一个vnode了，snabbdom是通过使用函数库中的<em>h.js</em>函数去生成vnode的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//h.js中的代码</div><div class="line">//这里先引入了对vnode的定义</div><div class="line">var VNode = require(&apos;./vnode&apos;);</div><div class="line">var is = require(&apos;./is&apos;);</div><div class="line"></div><div class="line">//为了使vnode支持SVG，特别添加该函数对包含svg的vnode中的data加入了svg特有的namespace（命名空间）属性</div><div class="line">function addNS(data, children) &#123;</div><div class="line">  data.ns = &apos;http://www.w3.org/2000/svg&apos;;</div><div class="line">  if (children !== undefined) &#123;</div><div class="line">    for (var i = 0; i &lt; children.length; ++i) &#123;</div><div class="line">      addNS(children[i].data, children[i].children);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//h函数的使用例子： h(&apos;div.page&apos;,&#123;style: fadeInOutStyle&#125;,[h(&apos;div.header&apos;,[h(&apos;div.header-content&apos;)])])</div><div class="line">//h函数的参数依次为： css选择器[节点类型(必须),类名或者ID等其他选择器],节点的数据,子vnode</div><div class="line">module.exports = function h(sel, b, c) &#123;</div><div class="line">  var data = &#123;&#125;, children, text, i;</div><div class="line">  //判断如果第三个参数不为空，那么第二个参数肯定存在</div><div class="line">  if (c !== undefined) &#123;</div><div class="line">    data = b;</div><div class="line">    if (is.array(c)) &#123; children = c; &#125;</div><div class="line">    //这里出现了is模块下的primitive函数，用于判断是否是基本类型(字符串，数字)</div><div class="line">    else if (is.primitive(c)) &#123; text = c; &#125;</div><div class="line">  &#125; else if (b !== undefined) &#123;</div><div class="line">    //判断第二个参数这个时候是代表着数据还是子节点集 </div><div class="line">    if (is.array(b)) &#123; children = b; &#125;</div><div class="line">    else if (is.primitive(b)) &#123; text = b; &#125;</div><div class="line">    else &#123; data = b; &#125;</div><div class="line">  &#125;</div><div class="line">  //判断是否有多个子节点</div><div class="line">  if (is.array(children)) &#123;</div><div class="line">    for (i = 0; i &lt; children.length; ++i) &#123;</div><div class="line">      //如果子节点是基本类型，就直接生成一个只包含文本的vnode节点，在文本参数后面的参数不需要写出来，默认就是undefined</div><div class="line">      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //判断生成的节点是否是SVG元素，如果是就需要为其增加namespace属性</div><div class="line">  if (sel[0] === &apos;s&apos; &amp;&amp; sel[1] === &apos;v&apos; &amp;&amp; sel[2] === &apos;g&apos;) &#123;</div><div class="line">    addNS(data, children);</div><div class="line">  &#125;</div><div class="line">  return VNode(sel, data, children, text, undefined);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>总结：  </p>
<ol>
<li>对svg元素进行包装，添加namespace</li>
<li>将vnode中的文字内容统一转换为string</li>
<li>把vnode.children中的string element 转化为textNode</li>
</ol>
<h2 id="判断基本类型"><a href="#判断基本类型" class="headerlink" title="判断基本类型"></a>判断基本类型</h2><p><em>is</em>函数在当前版本的作用就是用来提供对传入的数据进行类型检查。<br>代码相当简单，但是这种命名风格相当值得学习。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  array: Array.isArray,</div><div class="line">  primitive: function(s) &#123; return typeof s === &apos;string&apos; || typeof s === &apos;number&apos;; &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="对DOMAPI进行包装"><a href="#对DOMAPI进行包装" class="headerlink" title="对DOMAPI进行包装"></a>对DOMAPI进行包装</h2><p><em>htmldomapi.js</em>文件使用adapter模式，对domapi进行了包装，通过对原生api用函数进行包装，缩短了api调用代码长度。同时对原生api进行polyfill的时候不需要改动snabbom主文件中的代码。</p>
<h2 id="snabbdom主文件"><a href="#snabbdom主文件" class="headerlink" title="snabbdom主文件"></a>snabbdom主文件</h2><p>主文件实现了vdom 的diff 算法和为vdom的lifecycle hook。<br>因为snabbdom主文件的代码数量相对比较多，所以就不一次性把所有代码列出来了。  </p>
<h3 id="定义的接口和变量"><a href="#定义的接口和变量" class="headerlink" title="定义的接口和变量"></a>定义的接口和变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//虚拟节点的构造函数</div><div class="line">var VNode = require(&apos;./vnode&apos;);</div><div class="line">var is = require(&apos;./is&apos;);</div><div class="line">var domApi = require(&apos;./htmldomapi&apos;);</div><div class="line"></div><div class="line">//用于判读是否为undefined</div><div class="line">function isUndef(s) &#123; return s === undefined; &#125;</div><div class="line">function isDef(s) &#123; return s !== undefined; &#125;</div><div class="line"></div><div class="line">//生成一个空节点</div><div class="line">var emptyNode = VNode(&apos;&apos;, &#123;&#125;, [], undefined, undefined);</div></pre></td></tr></table></figure>
<h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><blockquote>
<p>snabbdom的核心只提供了最基本的功能。它的设计尽可能简单，同时仍然保证执行速度快和可扩展性。<br>为了保证snabbdom核心的简洁，文件中只暴露了<em>init</em>这个接口。init只有两个参数<em>module</em>、<em>api</em>。<br>module参数用于实现对snabbdom的扩展，api参数用于传入用户自行封装domapi，返回值则是<em>patch</em>函数（稍后会介绍）。<br>下面先介绍init函数的结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">function init(modules, api) &#123;</div><div class="line">  var i, j, cbs = &#123;&#125;;</div><div class="line">  //判断是否传入了用户自行封装的DOMAPI集合</div><div class="line">  if (isUndef(api)) api = domApi;</div><div class="line"></div><div class="line">  //生成对应钩子的回调函数集合</div><div class="line">  for (i = 0; i &lt; hooks.length; ++i) &#123;</div><div class="line">    cbs[hooks[i]] = [];</div><div class="line">    //检查传入模块中是否有对应钩子的回调函数，如果有的话就插入到队列当中</div><div class="line">    for (j = 0; j &lt; modules.length; ++j) &#123;</div><div class="line">      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //可以看到在init函数中定义了许多子函数来实现不同的功能。</div><div class="line">  //这里只进行简单介绍，代码分析在下一节。</div><div class="line">  //返回一个根据elm选择器对象生成的空vnode节点（只有id、class的节点）</div><div class="line">  function emptyNodeAt(elm) &#123;&#125;</div><div class="line">  //生成传入的节点的移除回调函数，</div><div class="line">  //当触发移除虚拟节点的时候回调函数将判断监听器数量并</div><div class="line">  //最终对DOM树进行移除节点的操作</div><div class="line">  function createRmCb(childElm, listeners) &#123;&#125;</div><div class="line">  //根据新增的Vnode生成对应的DOM节点</div><div class="line">  function createElm(vnode, insertedVnodeQueue) &#123;&#125;</div><div class="line">  //把新增的Vnode对应的DOM节点插入到DOM树中</div><div class="line">  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) &#123;&#125;</div><div class="line">  //移除vnode节点的时候递归触发子节点的destory钩子</div><div class="line">  function invokeDestroyHook(vnode) &#123;&#125;</div><div class="line">  //提供批量删除节点的功能</div><div class="line">  function removeVnodes(parentElm, vnodes, startIdx, endIdx) &#123;&#125;</div><div class="line">  //当一个节点有变动的时候触发,对该节点的子节点集合进行判断是否可以进行复用。</div><div class="line">  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) &#123;&#125;</div><div class="line">  //判断两个节点是否可以复用（直接通过打补丁的方式进行更新）</div><div class="line">  function patchVnode(oldVnode, vnode, insertedVnodeQueue) &#123;&#125;</div><div class="line">  //返回一个patch函数</div><div class="line">  return function(oldVnode, vnode) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="module参数"><a href="#module参数" class="headerlink" title="module参数"></a>module参数</h4><p>为了减少主文件的大小，snabbdom的主文件只提供了对DOM节点本身的操作,把其余功能如：</p>
<ol>
<li>添加eventlistener</li>
<li>设置DOM元素属性</li>
<li>切换类名</li>
<li>添加css动画<br>都分拆成模块，作为可选用功能。<br>因此，在需要使用这些功能的时候只需要引入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var patch = snabbdom.init([ </div><div class="line">  require(&apos;snabbdom/modules/class&apos;), </div><div class="line">  require(&apos;snabbdom/modules/props&apos;), </div><div class="line">  require(&apos;snabbdom/modules/style&apos;), </div><div class="line">  require(&apos;snabbdom/modules/eventlisteners&apos;), </div><div class="line">]);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="api参数"><a href="#api参数" class="headerlink" title="api参数"></a>api参数</h4><p>暂无</p>
<h3 id="vdom-diff算法"><a href="#vdom-diff算法" class="headerlink" title="vdom diff算法"></a>vdom diff算法</h3><p>接下来就到了最关键的diff算法。snabbdom的diff算法和react原理一致。<br>相比基于二叉树搜索的传统diff算法，时间复杂度达到O(n^3)！<a href="https://segmentfault.com/a/1190000004913592" target="_blank" rel="external">传统diff算法流程介绍</a>，snabbdom通过自己的特定策略，通过对diff场景分析分成两个算法把复杂度降低为O(n)复杂度和O(max(m,n))。<br>当然，要有收益就一定会有代价，这种搜索方法只对vnode的搜索起效。</p>
<ol>
<li>由于前端开发中很少会出现跨层级处理节点，只比较同层次的节点，如果该层次节点不一致放弃对子节点的比较</li>
<li>父节点一致时候，对子节点的状态进行判断（缺失，多余，失序）并进行相对应的操作<br>节点状态:</li>
<li>元素sel和key不一致 替换</li>
<li>元素的attrs不一致 替换</li>
<li>元素的textContent不一致 替换</li>
<li>元素失序 重新排序<h4 id="init返回的patch函数"><a href="#init返回的patch函数" class="headerlink" title="init返回的patch函数"></a>init返回的patch函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">function(oldVnode, vnode) &#123;</div><div class="line">    var i, elm, parent;</div><div class="line">    // insertedVnodeQueue保存着patch中新插入的vnode</div><div class="line">    var insertedVnodeQueue = [];</div><div class="line">    //触发所有的全局pre钩子</div><div class="line">    for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i]();</div><div class="line"></div><div class="line">    //对页面第一次进行patch的时候，因为还没有建立vnode树，所以是oldVnode是一个DOM元素</div><div class="line">    //这样就调用emptyVnode去生成对应的vnode</div><div class="line">    if (isUndef(oldVnode.sel)) &#123;</div><div class="line">      oldVnode = emptyNodeAt(oldVnode);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //判断同层次节点是否满足进行patch的最低要求（sel和key是否一样）</div><div class="line">    //如果不满足，直接对该子节点树移除。因为比较不同的元素如：</div><div class="line">    //diff一个&apos;span&apos;和&apos;div&apos;是没有意义的，同时因为key本身就是一个用来区分元素的值，</div><div class="line">    //因此key不一样也同样能够判断两个节点不一致</div><div class="line">    //对于不一样的节点树，直接移除然后重新生成新的节点树，插入到dom中。</div><div class="line">    if (sameVnode(oldVnode, vnode)) &#123;</div><div class="line">      patchVnode(oldVnode, vnode, insertedVnodeQueue);</div><div class="line">    &#125; else &#123;</div><div class="line">      elm = oldVnode.elm;</div><div class="line">      parent = api.parentNode(elm);</div><div class="line">      //递归生成插入点的新vnode子树</div><div class="line">      createElm(vnode, insertedVnodeQueue);</div><div class="line">      //将新创建的节点插入到parent中</div><div class="line">      if (parent !== null) &#123;</div><div class="line">        api.insertBefore(parent, vnode.elm, api.nextSibling(elm));</div><div class="line">        //然后移除旧节点，注意：为了进行参数适配oldVnode使用[]包裹</div><div class="line">        removeVnodes(parent, [oldVnode], 0, 0);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    //完成dom树更新后，触发被插入vnode的insert钩子</div><div class="line">    for (i = 0; i &lt; insertedVnodeQueue.length; ++i) &#123;</div><div class="line">      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);</div><div class="line">    &#125;</div><div class="line">    //patch结束，然后调用全局中所有的post钩子</div><div class="line">    for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i]();</div><div class="line">    return vnode;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>接下来看一下patch函数的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">//参数： 旧的vnode子树;新的vnode子树（根节点）;将要插入子树的Vnode队列</div><div class="line">function patchVnode(oldVnode, vnode, insertedVnodeQueue) &#123;</div><div class="line">    var i, hook;</div><div class="line">    //先对vnode检查是否定义了prepatch钩子（注意这里是vnode在data中定义钩子）</div><div class="line">    //不是上面提到的由框架在全局进行定义的钩子。</div><div class="line">    if (isDef(i = vnode.data) &amp;&amp; isDef(hook = i.hook) &amp;&amp; isDef(i = hook.prepatch)) &#123;</div><div class="line">      //调用钩子的回调函数</div><div class="line">      i(oldVnode, vnode);</div><div class="line">    &#125;</div><div class="line">    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;</div><div class="line">    //因为Vnode是JS对象，先进行引用判断，如果引用一致不需要patch。</div><div class="line">    //在良好设计的vdom里,大部分时间我们都在执行这个返回语句。</div><div class="line">    if (oldVnode === vnode) return;</div><div class="line">    //接下来判断节点的key和sel是否一致，一致才有继续判断的价值。</div><div class="line">    if (!sameVnode(oldVnode, vnode)) &#123;</div><div class="line">      var parentElm = api.parentNode(oldVnode.elm);</div><div class="line">      elm = createElm(vnode, insertedVnodeQueue);</div><div class="line">      api.insertBefore(parentElm, elm, oldVnode.elm);</div><div class="line">      removeVnodes(parentElm, [oldVnode], 0, 0);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    //两个node值得patch</div><div class="line">    //检查vnode是否有data因为在data更新时候需要触发update钩子</div><div class="line">    //先触发全局的update钩子再触发vnode自己的update钩子</div><div class="line">    if (isDef(vnode.data)) &#123;</div><div class="line">      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);</div><div class="line">      i = vnode.data.hook;</div><div class="line">      if (isDef(i) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode);</div><div class="line">    &#125;</div><div class="line">    // patch两个vnode的text和children</div><div class="line">    // 查看vnode.text定义</div><div class="line">    // vdom中规定,具有text属性的vnode不应该具备children</div><div class="line">    if (isUndef(vnode.text)) &#123;</div><div class="line">      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</div><div class="line">        //当子节点不一致对子节点进行检查</div><div class="line">        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);</div><div class="line">      &#125; else if (isDef(ch)) &#123;</div><div class="line">        //旧节点没有子节点，需要判断textContent</div><div class="line">        //需要先对移除旧DOM节点的text，否则patch后就会出现text+新node</div><div class="line">        if (isDef(oldVnode.text)) api.setTextContent(elm, &apos;&apos;);</div><div class="line">        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);</div><div class="line">      &#125; else if (isDef(oldCh)) &#123;</div><div class="line">        removeVnodes(elm, oldCh, 0, oldCh.length - 1);</div><div class="line">      &#125; else if (isDef(oldVnode.text)) &#123;</div><div class="line">        api.setTextContent(elm, &apos;&apos;);</div><div class="line">      &#125;</div><div class="line">    &#125; else if (oldVnode.text !== vnode.text) &#123;</div><div class="line">      api.setTextContent(elm, vnode.text);</div><div class="line">    &#125;</div><div class="line">    //触发postpatch钩子</div><div class="line">    if (isDef(hook) &amp;&amp; isDef(i = hook.postpatch)) &#123;</div><div class="line">      i(oldVnode, vnode);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>以上是对同层次的节点进行diff复杂度是O(n)，接下来再来看看对list的diff。<br>可以看到如果像上面的方法对每个子节点都进行同层次diff的话，一旦出现像:<br>1234567变成7123456就需要进行n次diff，这显然是不合理的。<br>可以看到分五种情况</p>
<ol>
<li>oldStartVnode和newStartVnode,两者elm相对位置不变,若值得(sameVnode)比较,这patch这两个vnode</li>
<li>oldEndVnode和newEndVnode,同上,elm相对位置不变,做相同patch检测</li>
<li>oldStartVnode和newEndVnode,如果oldStartVnode和newEndVnode值得比较,说明oldCh中的这个oldStartVnode.elm向右移动了。那么执行api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm))调整它的位置</li>
<li>oldEndVnode和newStartVnode,同上,但这是oldVnode.elm向左移,需要调整它的位置</li>
</ol>
<ol>
<li>利用vnode.key,在ul&gt;li*n的结构里,我们很有可能使用key来标志li的唯一性,那么我们就会来到最后一种情况。这个时候,我们先产生一个index-key表(createKeyToOldIdx),然后根据这个表来进行更改。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) &#123;</div><div class="line">   var oldStartIdx = 0, newStartIdx = 0;</div><div class="line">   var oldEndIdx = oldCh.length - 1;</div><div class="line">   var oldStartVnode = oldCh[0];</div><div class="line">   var oldEndVnode = oldCh[oldEndIdx];</div><div class="line">   var newEndIdx = newCh.length - 1;</div><div class="line">   var newStartVnode = newCh[0];</div><div class="line">   var newEndVnode = newCh[newEndIdx];</div><div class="line">   var oldKeyToIdx, idxInOld, elmToMove, before;</div><div class="line"></div><div class="line">   while (oldStartIdx = oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</div><div class="line">     if (isUndef(oldStartVnode)) &#123;</div><div class="line">       oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left</div><div class="line">     &#125; else if (isUndef(oldEndVnode)) &#123;</div><div class="line">       oldEndVnode = oldCh[--oldEndIdx];</div><div class="line">     &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</div><div class="line">       patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);</div><div class="line">       oldStartVnode = oldCh[++oldStartIdx];</div><div class="line">       newStartVnode = newCh[++newStartIdx];</div><div class="line">     &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</div><div class="line">       patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);</div><div class="line">       oldEndVnode = oldCh[--oldEndIdx];</div><div class="line">       newEndVnode = newCh[--newEndIdx];</div><div class="line">     &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</div><div class="line">       patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);</div><div class="line">       api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));</div><div class="line">       oldStartVnode = oldCh[++oldStartIdx];</div><div class="line">       newEndVnode = newCh[--newEndIdx];</div><div class="line">     &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</div><div class="line">       patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);</div><div class="line">       api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</div><div class="line">       oldEndVnode = oldCh[--oldEndIdx];</div><div class="line">       newStartVnode = newCh[++newStartIdx];</div><div class="line">     &#125; else &#123;</div><div class="line">       if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</div><div class="line">       idxInOld = oldKeyToIdx[newStartVnode.key];</div><div class="line">       if (isUndef(idxInOld)) &#123; // New element</div><div class="line">         api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);</div><div class="line">         newStartVnode = newCh[++newStartIdx];</div><div class="line">       &#125; else &#123;</div><div class="line">         elmToMove = oldCh[idxInOld];</div><div class="line">         patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);</div><div class="line">         oldCh[idxInOld] = undefined;</div><div class="line">         api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);</div><div class="line">         newStartVnode = newCh[++newStartIdx];</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   if (oldStartIdx &gt; oldEndIdx) &#123;</div><div class="line">     before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;</div><div class="line">     addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</div><div class="line">   &#125; else if (newStartIdx &gt; newEndIdx) &#123;</div><div class="line">     removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>注意：在vue过去的某个版本中，v-for指令的diff算法有缺陷，会产生额外的重排次数，下面引用自：<br><img src="https://github.com/vuejs/vue/issues/1807" alt=""></p>
<h3 id="vdom-lifecycle-hook"><a href="#vdom-lifecycle-hook" class="headerlink" title="vdom lifecycle hook"></a>vdom lifecycle hook</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var hooks = [&apos;create&apos;, &apos;update&apos;, &apos;remove&apos;, &apos;destroy&apos;, &apos;pre&apos;, &apos;post&apos;];</div></pre></td></tr></table></figure>
<p>从这行代码中可以看出，snabbdom提供了六个全局的hook。实际上共提供了以下钩子:<br>| 名字  |  触发时机  | 回调函数接受的参数 |<br>|——|———| ———-|<br>|pre | 在patch开始时触发 | 无|<br>|init | vnode创建时候触发 | vnode|<br>|create | vnode转换成dom节点时触发 |  emptyVnode,vnode|<br>| insert | 当一个Dom元素已被插入Dom树时候触发 | vnode|<br>|prepatch | 当一个DOM元素准备被patch前触发 | oldVnode，vnode|<br>|update | 元素更新时触发 | oldVnode，vnode |<br>|postpatch | 元素patch完成时触发| oldVnode，vnode|<br>|destory | 元素被删除时触发 | vnode |<br>|remove | 与destory区别在于只有在节点被直接移除时候触发|vnode，removeCallback |<br>|post | patch 完成后触发 | none|</p>

    

    
</div>


                

                <!-- Post Comments -->
                
                    




                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2017/04/09/360前端星计划-一/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2017/03/16/如何实现lazyman/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/myavatar.jpg" alt="kyjo2014's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        467346087@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/" target="_self">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/06/">六月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/11/">十一月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/10/">十月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/08/">八月 2017<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/07/">七月 2017<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/06/">六月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/04/">四月 2017<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/03/">三月 2017<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/10/">十月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/07/">七月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/04/">四月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/03/">三月 2016<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/11/">十一月 2015<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/10/">十月 2015<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/09/">九月 2015<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/08/">八月 2015<span class="sidebar_archives-count">10</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-twitter.png);">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-facebook.png);">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-gplus.png);">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="bestkyjo" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-github.png);">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;
            <script type="text/javascript">
                var fd = new Date();
                document.write(fd.getFullYear());
            </script>
            &nbsp;LTH's note book
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import File -->
<script src="/js/lazyload.min.js"></script>
<script src="/js/js.min.js"></script>
<script src="/js/nprogress.js"></script>

<script type="text/javascript">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- Swiftye -->


<!-- Local Search-->


<!-- Window Load-->
<script>
    $(window).load(function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });
</script>

<!-- MathJax Load-->


                </main>
            </div>
        </body>
    
</html>
